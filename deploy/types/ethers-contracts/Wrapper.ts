/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface WrapperInterface extends utils.Interface {
  functions: {
    "auctionIdMatchesToken(uint256,address,uint256)": FunctionFragment;
    "getMinimumBid(uint256)": FunctionFragment;
    "getCurrentHighestBidder(uint256)": FunctionFragment;
    "bid(uint256,uint256)": FunctionFragment;
    "isFinalized(uint256)": FunctionFragment;
    "finalize(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "auctionIdMatchesToken"
      | "getMinimumBid"
      | "getCurrentHighestBidder"
      | "bid"
      | "isFinalized"
      | "finalize"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "auctionIdMatchesToken",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMinimumBid",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentHighestBidder",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "bid",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isFinalized",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "finalize",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "auctionIdMatchesToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMinimumBid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentHighestBidder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bid", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isFinalized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finalize", data: BytesLike): Result;

  events: {};
}

export interface Wrapper extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: WrapperInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Called in PartyBid.sol in `initialize` at line 174
     * Given the auctionId, nftContract, and tokenId, check that: 1. the auction ID matches the token referred to by tokenId + nftContract 2. the auctionId refers to an *ACTIVE* auction (e.g. an auction that will accept bids) within this market contract 3. any additional validation to ensure that a PartyBid can bid on this auction (ex: if the market allows arbitrary bidding currencies, check that the auction currency is ETH) Note: This function probably should have been named "isValidAuction"
     */
    auctionIdMatchesToken(
      auctionId: PromiseOrValue<BigNumberish>,
      nftContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Called in PartyBid.sol in `bid` at line 251
     * Calculate the minimum next bid for this auction. PartyBid contracts always submit the minimum possible bid that will be accepted by the Market contract. usually, this is either the reserve price (if there are no bids) or a certain percentage increase above the current highest bid
     */
    getMinimumBid(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Called in PartyBid.sol in `bid` at line 241
     * Query the current highest bidder for this auction It is assumed that there is always 1 winning highest bidder for an auction This is used to ensure that PartyBid cannot outbid itself if it is already winning
     */
    getCurrentHighestBidder(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Called in PartyBid.sol in `bid` at line 259
     * Submit bid to Market contract
     */
    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called in PartyBid.sol in `bid` at line 247and in `finalize` at line 288
     * Determine whether the auction has been finalized Used to check if it is still possible to bid And to determine whether the PartyBid should finalize the auction
     */
    isFinalized(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Called in PartyBid.sol in `finalize` at line 289
     * Finalize the results of the auction on the Market contract It is assumed  that this operation is performed once for each auction, that after it is done the auction is over and the NFT has been transferred to the auction winner.
     */
    finalize(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  /**
   * Called in PartyBid.sol in `initialize` at line 174
   * Given the auctionId, nftContract, and tokenId, check that: 1. the auction ID matches the token referred to by tokenId + nftContract 2. the auctionId refers to an *ACTIVE* auction (e.g. an auction that will accept bids) within this market contract 3. any additional validation to ensure that a PartyBid can bid on this auction (ex: if the market allows arbitrary bidding currencies, check that the auction currency is ETH) Note: This function probably should have been named "isValidAuction"
   */
  auctionIdMatchesToken(
    auctionId: PromiseOrValue<BigNumberish>,
    nftContract: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Called in PartyBid.sol in `bid` at line 251
   * Calculate the minimum next bid for this auction. PartyBid contracts always submit the minimum possible bid that will be accepted by the Market contract. usually, this is either the reserve price (if there are no bids) or a certain percentage increase above the current highest bid
   */
  getMinimumBid(
    auctionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Called in PartyBid.sol in `bid` at line 241
   * Query the current highest bidder for this auction It is assumed that there is always 1 winning highest bidder for an auction This is used to ensure that PartyBid cannot outbid itself if it is already winning
   */
  getCurrentHighestBidder(
    auctionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Called in PartyBid.sol in `bid` at line 259
   * Submit bid to Market contract
   */
  bid(
    auctionId: PromiseOrValue<BigNumberish>,
    bidAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called in PartyBid.sol in `bid` at line 247and in `finalize` at line 288
   * Determine whether the auction has been finalized Used to check if it is still possible to bid And to determine whether the PartyBid should finalize the auction
   */
  isFinalized(
    auctionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Called in PartyBid.sol in `finalize` at line 289
   * Finalize the results of the auction on the Market contract It is assumed  that this operation is performed once for each auction, that after it is done the auction is over and the NFT has been transferred to the auction winner.
   */
  finalize(
    auctionId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Called in PartyBid.sol in `initialize` at line 174
     * Given the auctionId, nftContract, and tokenId, check that: 1. the auction ID matches the token referred to by tokenId + nftContract 2. the auctionId refers to an *ACTIVE* auction (e.g. an auction that will accept bids) within this market contract 3. any additional validation to ensure that a PartyBid can bid on this auction (ex: if the market allows arbitrary bidding currencies, check that the auction currency is ETH) Note: This function probably should have been named "isValidAuction"
     */
    auctionIdMatchesToken(
      auctionId: PromiseOrValue<BigNumberish>,
      nftContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Called in PartyBid.sol in `bid` at line 251
     * Calculate the minimum next bid for this auction. PartyBid contracts always submit the minimum possible bid that will be accepted by the Market contract. usually, this is either the reserve price (if there are no bids) or a certain percentage increase above the current highest bid
     */
    getMinimumBid(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called in PartyBid.sol in `bid` at line 241
     * Query the current highest bidder for this auction It is assumed that there is always 1 winning highest bidder for an auction This is used to ensure that PartyBid cannot outbid itself if it is already winning
     */
    getCurrentHighestBidder(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Called in PartyBid.sol in `bid` at line 259
     * Submit bid to Market contract
     */
    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called in PartyBid.sol in `bid` at line 247and in `finalize` at line 288
     * Determine whether the auction has been finalized Used to check if it is still possible to bid And to determine whether the PartyBid should finalize the auction
     */
    isFinalized(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Called in PartyBid.sol in `finalize` at line 289
     * Finalize the results of the auction on the Market contract It is assumed  that this operation is performed once for each auction, that after it is done the auction is over and the NFT has been transferred to the auction winner.
     */
    finalize(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {};

  estimateGas: {
    /**
     * Called in PartyBid.sol in `initialize` at line 174
     * Given the auctionId, nftContract, and tokenId, check that: 1. the auction ID matches the token referred to by tokenId + nftContract 2. the auctionId refers to an *ACTIVE* auction (e.g. an auction that will accept bids) within this market contract 3. any additional validation to ensure that a PartyBid can bid on this auction (ex: if the market allows arbitrary bidding currencies, check that the auction currency is ETH) Note: This function probably should have been named "isValidAuction"
     */
    auctionIdMatchesToken(
      auctionId: PromiseOrValue<BigNumberish>,
      nftContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called in PartyBid.sol in `bid` at line 251
     * Calculate the minimum next bid for this auction. PartyBid contracts always submit the minimum possible bid that will be accepted by the Market contract. usually, this is either the reserve price (if there are no bids) or a certain percentage increase above the current highest bid
     */
    getMinimumBid(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called in PartyBid.sol in `bid` at line 241
     * Query the current highest bidder for this auction It is assumed that there is always 1 winning highest bidder for an auction This is used to ensure that PartyBid cannot outbid itself if it is already winning
     */
    getCurrentHighestBidder(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called in PartyBid.sol in `bid` at line 259
     * Submit bid to Market contract
     */
    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called in PartyBid.sol in `bid` at line 247and in `finalize` at line 288
     * Determine whether the auction has been finalized Used to check if it is still possible to bid And to determine whether the PartyBid should finalize the auction
     */
    isFinalized(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called in PartyBid.sol in `finalize` at line 289
     * Finalize the results of the auction on the Market contract It is assumed  that this operation is performed once for each auction, that after it is done the auction is over and the NFT has been transferred to the auction winner.
     */
    finalize(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Called in PartyBid.sol in `initialize` at line 174
     * Given the auctionId, nftContract, and tokenId, check that: 1. the auction ID matches the token referred to by tokenId + nftContract 2. the auctionId refers to an *ACTIVE* auction (e.g. an auction that will accept bids) within this market contract 3. any additional validation to ensure that a PartyBid can bid on this auction (ex: if the market allows arbitrary bidding currencies, check that the auction currency is ETH) Note: This function probably should have been named "isValidAuction"
     */
    auctionIdMatchesToken(
      auctionId: PromiseOrValue<BigNumberish>,
      nftContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called in PartyBid.sol in `bid` at line 251
     * Calculate the minimum next bid for this auction. PartyBid contracts always submit the minimum possible bid that will be accepted by the Market contract. usually, this is either the reserve price (if there are no bids) or a certain percentage increase above the current highest bid
     */
    getMinimumBid(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called in PartyBid.sol in `bid` at line 241
     * Query the current highest bidder for this auction It is assumed that there is always 1 winning highest bidder for an auction This is used to ensure that PartyBid cannot outbid itself if it is already winning
     */
    getCurrentHighestBidder(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called in PartyBid.sol in `bid` at line 259
     * Submit bid to Market contract
     */
    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called in PartyBid.sol in `bid` at line 247and in `finalize` at line 288
     * Determine whether the auction has been finalized Used to check if it is still possible to bid And to determine whether the PartyBid should finalize the auction
     */
    isFinalized(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called in PartyBid.sol in `finalize` at line 289
     * Finalize the results of the auction on the Market contract It is assumed  that this operation is performed once for each auction, that after it is done the auction is over and the NFT has been transferred to the auction winner.
     */
    finalize(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
