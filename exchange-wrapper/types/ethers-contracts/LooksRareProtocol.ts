/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace ILooksRareProtocol {
  export type NonceInvalidationParametersStruct = {
    orderHash: PromiseOrValue<BytesLike>;
    orderNonce: PromiseOrValue<BigNumberish>;
    isNonceInvalidated: PromiseOrValue<boolean>;
  };

  export type NonceInvalidationParametersStructOutput = [
    string,
    BigNumber,
    boolean
  ] & { orderHash: string; orderNonce: BigNumber; isNonceInvalidated: boolean };
}

export declare namespace OrderStructs {
  export type TakerStruct = {
    recipient: PromiseOrValue<string>;
    additionalParameters: PromiseOrValue<BytesLike>;
  };

  export type TakerStructOutput = [string, string] & {
    recipient: string;
    additionalParameters: string;
  };

  export type MakerStruct = {
    quoteType: PromiseOrValue<BigNumberish>;
    globalNonce: PromiseOrValue<BigNumberish>;
    subsetNonce: PromiseOrValue<BigNumberish>;
    orderNonce: PromiseOrValue<BigNumberish>;
    strategyId: PromiseOrValue<BigNumberish>;
    collectionType: PromiseOrValue<BigNumberish>;
    collection: PromiseOrValue<string>;
    currency: PromiseOrValue<string>;
    signer: PromiseOrValue<string>;
    startTime: PromiseOrValue<BigNumberish>;
    endTime: PromiseOrValue<BigNumberish>;
    price: PromiseOrValue<BigNumberish>;
    itemIds: PromiseOrValue<BigNumberish>[];
    amounts: PromiseOrValue<BigNumberish>[];
    additionalParameters: PromiseOrValue<BytesLike>;
  };

  export type MakerStructOutput = [
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[],
    BigNumber[],
    string
  ] & {
    quoteType: number;
    globalNonce: BigNumber;
    subsetNonce: BigNumber;
    orderNonce: BigNumber;
    strategyId: BigNumber;
    collectionType: number;
    collection: string;
    currency: string;
    signer: string;
    startTime: BigNumber;
    endTime: BigNumber;
    price: BigNumber;
    itemIds: BigNumber[];
    amounts: BigNumber[];
    additionalParameters: string;
  };

  export type MerkleTreeNodeStruct = {
    value: PromiseOrValue<BytesLike>;
    position: PromiseOrValue<BigNumberish>;
  };

  export type MerkleTreeNodeStructOutput = [string, number] & {
    value: string;
    position: number;
  };

  export type MerkleTreeStruct = {
    root: PromiseOrValue<BytesLike>;
    proof: OrderStructs.MerkleTreeNodeStruct[];
  };

  export type MerkleTreeStructOutput = [
    string,
    OrderStructs.MerkleTreeNodeStructOutput[]
  ] & { root: string; proof: OrderStructs.MerkleTreeNodeStructOutput[] };
}

export interface LooksRareProtocolInterface extends utils.Interface {
  functions: {
    "MAGIC_VALUE_ORDER_NONCE_EXECUTED()": FunctionFragment;
    "WETH()": FunctionFragment;
    "addStrategy(uint16,uint16,uint16,bytes4,bool,address)": FunctionFragment;
    "affiliateController()": FunctionFragment;
    "affiliateRates(address)": FunctionFragment;
    "cancelOrderNonces(uint256[])": FunctionFragment;
    "cancelOwnershipTransfer()": FunctionFragment;
    "cancelSubsetNonces(uint256[])": FunctionFragment;
    "chainId()": FunctionFragment;
    "confirmOwnershipRenouncement()": FunctionFragment;
    "confirmOwnershipTransfer()": FunctionFragment;
    "creatorFeeManager()": FunctionFragment;
    "domainSeparator()": FunctionFragment;
    "hashBatchOrder(bytes32,uint256)": FunctionFragment;
    "incrementBidAskNonces(bool,bool)": FunctionFragment;
    "initiateOwnershipRenouncement()": FunctionFragment;
    "initiateOwnershipTransfer(address)": FunctionFragment;
    "isAffiliateProgramActive()": FunctionFragment;
    "isCurrencyAllowed(address)": FunctionFragment;
    "maxCreatorFeeBp()": FunctionFragment;
    "owner()": FunctionFragment;
    "ownershipStatus()": FunctionFragment;
    "potentialOwner()": FunctionFragment;
    "protocolFeeRecipient()": FunctionFragment;
    "strategyInfo(uint256)": FunctionFragment;
    "transferManager()": FunctionFragment;
    "updateAffiliateController(address)": FunctionFragment;
    "updateAffiliateProgramStatus(bool)": FunctionFragment;
    "updateAffiliateRate(address,uint256)": FunctionFragment;
    "updateCreatorFeeManager(address)": FunctionFragment;
    "updateCurrencyStatus(address,bool)": FunctionFragment;
    "updateMaxCreatorFeeBp(uint16)": FunctionFragment;
    "updateProtocolFeeRecipient(address)": FunctionFragment;
    "updateStrategy(uint256,bool,uint16,uint16)": FunctionFragment;
    "userBidAskNonces(address)": FunctionFragment;
    "userOrderNonce(address,uint256)": FunctionFragment;
    "userSubsetNonce(address,uint256)": FunctionFragment;
    "executeTakerAsk((address,bytes),(uint8,uint256,uint256,uint256,uint256,uint8,address,address,address,uint256,uint256,uint256,uint256[],uint256[],bytes),bytes,(bytes32,(bytes32,uint8)[]),address)": FunctionFragment;
    "executeTakerBid((address,bytes),(uint8,uint256,uint256,uint256,uint256,uint8,address,address,address,uint256,uint256,uint256,uint256[],uint256[],bytes),bytes,(bytes32,(bytes32,uint8)[]),address)": FunctionFragment;
    "executeMultipleTakerBids((address,bytes)[],(uint8,uint256,uint256,uint256,uint256,uint8,address,address,address,uint256,uint256,uint256,uint256[],uint256[],bytes)[],bytes[],(bytes32,(bytes32,uint8)[])[],address,bool)": FunctionFragment;
    "restrictedExecuteTakerBid((address,bytes),(uint8,uint256,uint256,uint256,uint256,uint8,address,address,address,uint256,uint256,uint256,uint256[],uint256[],bytes),address,bytes32)": FunctionFragment;
    "updateDomainSeparator()": FunctionFragment;
    "updateETHGasLimitForTransfer(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MAGIC_VALUE_ORDER_NONCE_EXECUTED"
      | "WETH"
      | "addStrategy"
      | "affiliateController"
      | "affiliateRates"
      | "cancelOrderNonces"
      | "cancelOwnershipTransfer"
      | "cancelSubsetNonces"
      | "chainId"
      | "confirmOwnershipRenouncement"
      | "confirmOwnershipTransfer"
      | "creatorFeeManager"
      | "domainSeparator"
      | "hashBatchOrder"
      | "incrementBidAskNonces"
      | "initiateOwnershipRenouncement"
      | "initiateOwnershipTransfer"
      | "isAffiliateProgramActive"
      | "isCurrencyAllowed"
      | "maxCreatorFeeBp"
      | "owner"
      | "ownershipStatus"
      | "potentialOwner"
      | "protocolFeeRecipient"
      | "strategyInfo"
      | "transferManager"
      | "updateAffiliateController"
      | "updateAffiliateProgramStatus"
      | "updateAffiliateRate"
      | "updateCreatorFeeManager"
      | "updateCurrencyStatus"
      | "updateMaxCreatorFeeBp"
      | "updateProtocolFeeRecipient"
      | "updateStrategy"
      | "userBidAskNonces"
      | "userOrderNonce"
      | "userSubsetNonce"
      | "executeTakerAsk"
      | "executeTakerBid"
      | "executeMultipleTakerBids"
      | "restrictedExecuteTakerBid"
      | "updateDomainSeparator"
      | "updateETHGasLimitForTransfer"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MAGIC_VALUE_ORDER_NONCE_EXECUTED",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "addStrategy",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "affiliateController",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "affiliateRates",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrderNonces",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOwnershipTransfer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelSubsetNonces",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(functionFragment: "chainId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "confirmOwnershipRenouncement",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "confirmOwnershipTransfer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creatorFeeManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hashBatchOrder",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementBidAskNonces",
    values: [PromiseOrValue<boolean>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "initiateOwnershipRenouncement",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initiateOwnershipTransfer",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAffiliateProgramActive",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isCurrencyAllowed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "maxCreatorFeeBp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownershipStatus",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "potentialOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "strategyInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateAffiliateController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAffiliateProgramStatus",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAffiliateRate",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateCreatorFeeManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateCurrencyStatus",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMaxCreatorFeeBp",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateProtocolFeeRecipient",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStrategy",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "userBidAskNonces",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "userOrderNonce",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "userSubsetNonce",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTakerAsk",
    values: [
      OrderStructs.TakerStruct,
      OrderStructs.MakerStruct,
      PromiseOrValue<BytesLike>,
      OrderStructs.MerkleTreeStruct,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTakerBid",
    values: [
      OrderStructs.TakerStruct,
      OrderStructs.MakerStruct,
      PromiseOrValue<BytesLike>,
      OrderStructs.MerkleTreeStruct,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeMultipleTakerBids",
    values: [
      OrderStructs.TakerStruct[],
      OrderStructs.MakerStruct[],
      PromiseOrValue<BytesLike>[],
      OrderStructs.MerkleTreeStruct[],
      PromiseOrValue<string>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "restrictedExecuteTakerBid",
    values: [
      OrderStructs.TakerStruct,
      OrderStructs.MakerStruct,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateDomainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateETHGasLimitForTransfer",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "MAGIC_VALUE_ORDER_NONCE_EXECUTED",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "affiliateController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "affiliateRates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrderNonces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOwnershipTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelSubsetNonces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "chainId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "confirmOwnershipRenouncement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "confirmOwnershipTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creatorFeeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "domainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hashBatchOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementBidAskNonces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initiateOwnershipRenouncement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initiateOwnershipTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAffiliateProgramActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCurrencyAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxCreatorFeeBp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ownershipStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "potentialOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "strategyInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAffiliateController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAffiliateProgramStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAffiliateRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateCreatorFeeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateCurrencyStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMaxCreatorFeeBp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateProtocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userBidAskNonces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userOrderNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userSubsetNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTakerAsk",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTakerBid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeMultipleTakerBids",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "restrictedExecuteTakerBid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateDomainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateETHGasLimitForTransfer",
    data: BytesLike
  ): Result;

  events: {
    "AffiliatePayment(address,address,uint256)": EventFragment;
    "CancelOwnershipTransfer()": EventFragment;
    "CurrencyStatusUpdated(address,bool)": EventFragment;
    "InitiateOwnershipRenouncement()": EventFragment;
    "InitiateOwnershipTransfer(address,address)": EventFragment;
    "NewAffiliateController(address)": EventFragment;
    "NewAffiliateProgramStatus(bool)": EventFragment;
    "NewAffiliateRate(address,uint256)": EventFragment;
    "NewBidAskNonces(address,uint256,uint256)": EventFragment;
    "NewCreatorFeeManager(address)": EventFragment;
    "NewDomainSeparator()": EventFragment;
    "NewGasLimitETHTransfer(uint256)": EventFragment;
    "NewMaxCreatorFeeBp(uint256)": EventFragment;
    "NewOwner(address)": EventFragment;
    "NewProtocolFeeRecipient(address)": EventFragment;
    "NewStrategy(uint256,uint16,uint16,uint16,bytes4,bool,address)": EventFragment;
    "OrderNoncesCancelled(address,uint256[])": EventFragment;
    "StrategyUpdated(uint256,bool,uint16,uint16)": EventFragment;
    "SubsetNoncesCancelled(address,uint256[])": EventFragment;
    "TakerAsk(tuple,address,address,uint256,address,address,uint256[],uint256[],address[2],uint256[3])": EventFragment;
    "TakerBid(tuple,address,address,uint256,address,address,uint256[],uint256[],address[2],uint256[3])": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AffiliatePayment"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CancelOwnershipTransfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CurrencyStatusUpdated"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "InitiateOwnershipRenouncement"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "InitiateOwnershipTransfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewAffiliateController"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewAffiliateProgramStatus"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewAffiliateRate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBidAskNonces"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewCreatorFeeManager"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewDomainSeparator"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewGasLimitETHTransfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewMaxCreatorFeeBp"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewProtocolFeeRecipient"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewStrategy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderNoncesCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StrategyUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SubsetNoncesCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TakerAsk"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TakerBid"): EventFragment;
}

export interface AffiliatePaymentEventObject {
  affiliate: string;
  currency: string;
  affiliateFee: BigNumber;
}
export type AffiliatePaymentEvent = TypedEvent<
  [string, string, BigNumber],
  AffiliatePaymentEventObject
>;

export type AffiliatePaymentEventFilter =
  TypedEventFilter<AffiliatePaymentEvent>;

export interface CancelOwnershipTransferEventObject {}
export type CancelOwnershipTransferEvent = TypedEvent<
  [],
  CancelOwnershipTransferEventObject
>;

export type CancelOwnershipTransferEventFilter =
  TypedEventFilter<CancelOwnershipTransferEvent>;

export interface CurrencyStatusUpdatedEventObject {
  currency: string;
  isAllowed: boolean;
}
export type CurrencyStatusUpdatedEvent = TypedEvent<
  [string, boolean],
  CurrencyStatusUpdatedEventObject
>;

export type CurrencyStatusUpdatedEventFilter =
  TypedEventFilter<CurrencyStatusUpdatedEvent>;

export interface InitiateOwnershipRenouncementEventObject {}
export type InitiateOwnershipRenouncementEvent = TypedEvent<
  [],
  InitiateOwnershipRenouncementEventObject
>;

export type InitiateOwnershipRenouncementEventFilter =
  TypedEventFilter<InitiateOwnershipRenouncementEvent>;

export interface InitiateOwnershipTransferEventObject {
  previousOwner: string;
  potentialOwner: string;
}
export type InitiateOwnershipTransferEvent = TypedEvent<
  [string, string],
  InitiateOwnershipTransferEventObject
>;

export type InitiateOwnershipTransferEventFilter =
  TypedEventFilter<InitiateOwnershipTransferEvent>;

export interface NewAffiliateControllerEventObject {
  affiliateController: string;
}
export type NewAffiliateControllerEvent = TypedEvent<
  [string],
  NewAffiliateControllerEventObject
>;

export type NewAffiliateControllerEventFilter =
  TypedEventFilter<NewAffiliateControllerEvent>;

export interface NewAffiliateProgramStatusEventObject {
  isActive: boolean;
}
export type NewAffiliateProgramStatusEvent = TypedEvent<
  [boolean],
  NewAffiliateProgramStatusEventObject
>;

export type NewAffiliateProgramStatusEventFilter =
  TypedEventFilter<NewAffiliateProgramStatusEvent>;

export interface NewAffiliateRateEventObject {
  affiliate: string;
  rate: BigNumber;
}
export type NewAffiliateRateEvent = TypedEvent<
  [string, BigNumber],
  NewAffiliateRateEventObject
>;

export type NewAffiliateRateEventFilter =
  TypedEventFilter<NewAffiliateRateEvent>;

export interface NewBidAskNoncesEventObject {
  user: string;
  bidNonce: BigNumber;
  askNonce: BigNumber;
}
export type NewBidAskNoncesEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  NewBidAskNoncesEventObject
>;

export type NewBidAskNoncesEventFilter = TypedEventFilter<NewBidAskNoncesEvent>;

export interface NewCreatorFeeManagerEventObject {
  creatorFeeManager: string;
}
export type NewCreatorFeeManagerEvent = TypedEvent<
  [string],
  NewCreatorFeeManagerEventObject
>;

export type NewCreatorFeeManagerEventFilter =
  TypedEventFilter<NewCreatorFeeManagerEvent>;

export interface NewDomainSeparatorEventObject {}
export type NewDomainSeparatorEvent = TypedEvent<
  [],
  NewDomainSeparatorEventObject
>;

export type NewDomainSeparatorEventFilter =
  TypedEventFilter<NewDomainSeparatorEvent>;

export interface NewGasLimitETHTransferEventObject {
  gasLimitETHTransfer: BigNumber;
}
export type NewGasLimitETHTransferEvent = TypedEvent<
  [BigNumber],
  NewGasLimitETHTransferEventObject
>;

export type NewGasLimitETHTransferEventFilter =
  TypedEventFilter<NewGasLimitETHTransferEvent>;

export interface NewMaxCreatorFeeBpEventObject {
  maxCreatorFeeBp: BigNumber;
}
export type NewMaxCreatorFeeBpEvent = TypedEvent<
  [BigNumber],
  NewMaxCreatorFeeBpEventObject
>;

export type NewMaxCreatorFeeBpEventFilter =
  TypedEventFilter<NewMaxCreatorFeeBpEvent>;

export interface NewOwnerEventObject {
  newOwner: string;
}
export type NewOwnerEvent = TypedEvent<[string], NewOwnerEventObject>;

export type NewOwnerEventFilter = TypedEventFilter<NewOwnerEvent>;

export interface NewProtocolFeeRecipientEventObject {
  protocolFeeRecipient: string;
}
export type NewProtocolFeeRecipientEvent = TypedEvent<
  [string],
  NewProtocolFeeRecipientEventObject
>;

export type NewProtocolFeeRecipientEventFilter =
  TypedEventFilter<NewProtocolFeeRecipientEvent>;

export interface NewStrategyEventObject {
  strategyId: BigNumber;
  standardProtocolFeeBp: number;
  minTotalFeeBp: number;
  maxProtocolFeeBp: number;
  selector: string;
  isMakerBid: boolean;
  implementation: string;
}
export type NewStrategyEvent = TypedEvent<
  [BigNumber, number, number, number, string, boolean, string],
  NewStrategyEventObject
>;

export type NewStrategyEventFilter = TypedEventFilter<NewStrategyEvent>;

export interface OrderNoncesCancelledEventObject {
  user: string;
  orderNonces: BigNumber[];
}
export type OrderNoncesCancelledEvent = TypedEvent<
  [string, BigNumber[]],
  OrderNoncesCancelledEventObject
>;

export type OrderNoncesCancelledEventFilter =
  TypedEventFilter<OrderNoncesCancelledEvent>;

export interface StrategyUpdatedEventObject {
  strategyId: BigNumber;
  isActive: boolean;
  standardProtocolFeeBp: number;
  minTotalFeeBp: number;
}
export type StrategyUpdatedEvent = TypedEvent<
  [BigNumber, boolean, number, number],
  StrategyUpdatedEventObject
>;

export type StrategyUpdatedEventFilter = TypedEventFilter<StrategyUpdatedEvent>;

export interface SubsetNoncesCancelledEventObject {
  user: string;
  subsetNonces: BigNumber[];
}
export type SubsetNoncesCancelledEvent = TypedEvent<
  [string, BigNumber[]],
  SubsetNoncesCancelledEventObject
>;

export type SubsetNoncesCancelledEventFilter =
  TypedEventFilter<SubsetNoncesCancelledEvent>;

export interface TakerAskEventObject {
  nonceInvalidationParameters: ILooksRareProtocol.NonceInvalidationParametersStructOutput;
  askUser: string;
  bidUser: string;
  strategyId: BigNumber;
  currency: string;
  collection: string;
  itemIds: BigNumber[];
  amounts: BigNumber[];
  feeRecipients: [string, string];
  feeAmounts: [BigNumber, BigNumber, BigNumber];
}
export type TakerAskEvent = TypedEvent<
  [
    ILooksRareProtocol.NonceInvalidationParametersStructOutput,
    string,
    string,
    BigNumber,
    string,
    string,
    BigNumber[],
    BigNumber[],
    [string, string],
    [BigNumber, BigNumber, BigNumber]
  ],
  TakerAskEventObject
>;

export type TakerAskEventFilter = TypedEventFilter<TakerAskEvent>;

export interface TakerBidEventObject {
  nonceInvalidationParameters: ILooksRareProtocol.NonceInvalidationParametersStructOutput;
  bidUser: string;
  bidRecipient: string;
  strategyId: BigNumber;
  currency: string;
  collection: string;
  itemIds: BigNumber[];
  amounts: BigNumber[];
  feeRecipients: [string, string];
  feeAmounts: [BigNumber, BigNumber, BigNumber];
}
export type TakerBidEvent = TypedEvent<
  [
    ILooksRareProtocol.NonceInvalidationParametersStructOutput,
    string,
    string,
    BigNumber,
    string,
    string,
    BigNumber[],
    BigNumber[],
    [string, string],
    [BigNumber, BigNumber, BigNumber]
  ],
  TakerBidEventObject
>;

export type TakerBidEventFilter = TypedEventFilter<TakerBidEvent>;

export interface LooksRareProtocol extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LooksRareProtocolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Magic value nonce returned if executed (or cancelled).
     */
    MAGIC_VALUE_ORDER_NONCE_EXECUTED(
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Wrapped ETH.
     */
    WETH(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Strategies have an id that is incremental.      Only callable by owner.
     * This function allows the owner to add a new execution strategy to the protocol.
     * @param implementation Implementation address
     * @param isMakerBid Whether the function selector is for maker bid
     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)
     * @param minTotalFeeBp Minimum total fee (in basis point)
     * @param selector Function selector for the strategy
     * @param standardProtocolFeeBp Standard protocol fee (in basis point)
     */
    addStrategy(
      standardProtocolFeeBp: PromiseOrValue<BigNumberish>,
      minTotalFeeBp: PromiseOrValue<BigNumberish>,
      maxProtocolFeeBp: PromiseOrValue<BigNumberish>,
      selector: PromiseOrValue<BytesLike>,
      isMakerBid: PromiseOrValue<boolean>,
      implementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Address of the affiliate controller.
     */
    affiliateController(overrides?: CallOverrides): Promise<[string]>;

    /**
     * It tracks the affiliate rate (in basis point) for a given affiliate address.         The basis point represents how much of the protocol fee will be shared to the affiliate.
     */
    affiliateRates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * It does not check the status of the nonces to save gas      and to prevent revertion if one of the orders is filled in the same      block.
     * This function allows a user to cancel an array of order nonces.
     * @param orderNonces Array of order nonces
     */
    cancelOrderNonces(
      orderNonces: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function can be used for both cancelling a transfer to a new owner and      cancelling the renouncement of the ownership.
     * This function is used to cancel the ownership transfer.
     */
    cancelOwnershipTransfer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * It does not check the status of the nonces to save gas.
     * This function allows a user to cancel an array of subset nonces.
     * @param subsetNonces Array of subset nonces
     */
    cancelSubsetNonces(
      subsetNonces: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Current chainId.
     */
    chainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * This function is used to confirm the ownership renouncement.
     */
    confirmOwnershipRenouncement(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function can only be called by the current potential owner.
     * This function is used to confirm the ownership transfer.
     */
    confirmOwnershipTransfer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Creator fee manager.
     */
    creatorFeeManager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Current domain separator.
     */
    domainSeparator(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This function returns the hash of the concatenation of batch order type hash and merkle root.
     * @param proofLength Merkle proof length
     * @param root Merkle root
     */
    hashBatchOrder(
      root: PromiseOrValue<BytesLike>,
      proofLength: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { batchOrderHash: string }>;

    /**
     * The logic for computing the quasi-random number is inspired by Seaport v1.2.      The pseudo-randomness allows non-deterministic computation of the next ask/bid nonce.      A deterministic increment would make the cancel-all process non-effective in certain cases      (orders signed with a greater ask/bid nonce).      The same quasi-random number is used for incrementing both the bid and ask nonces if both values      are incremented in the same transaction.      If this function is used twice in the same block, it will return the same quasiRandomNumber      but this will not impact the overall business logic.
     * This function increments a user's bid/ask nonces.
     * @param ask Whether to increment the user ask nonce
     * @param bid Whether to increment the user bid nonce
     */
    incrementBidAskNonces(
      bid: PromiseOrValue<boolean>,
      ask: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function is used to initiate the ownership renouncement.
     */
    initiateOwnershipRenouncement(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function is used to initiate the transfer of ownership to a new owner.
     * @param newPotentialOwner New potential owner address
     */
    initiateOwnershipTransfer(
      newPotentialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Whether the affiliate program is active.
     */
    isAffiliateProgramActive(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * It checks whether the currency is allowed for transacting.
     */
    isCurrencyAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Maximum creator fee (in basis point).
     */
    maxCreatorFeeBp(overrides?: CallOverrides): Promise<[number]>;

    /**
     * Address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Ownership status.
     */
    ownershipStatus(overrides?: CallOverrides): Promise<[number]>;

    /**
     * Address of the potential owner.
     */
    potentialOwner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Protocol fee recipient.
     */
    protocolFeeRecipient(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This returns the strategy information for a strategy id.
     */
    strategyInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, number, number, number, string, boolean, string] & {
        isActive: boolean;
        standardProtocolFeeBp: number;
        minTotalFeeBp: number;
        maxProtocolFeeBp: number;
        selector: string;
        isMakerBid: boolean;
        implementation: string;
      }
    >;

    /**
     * Transfer manager for ERC721 and ERC1155.
     */
    transferManager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate controller address.
     * @param newAffiliateController New affiliate controller address
     */
    updateAffiliateController(
      newAffiliateController: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate program status.
     * @param isActive Whether the affiliate program is active
     */
    updateAffiliateProgramStatus(
      isActive: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function allows the affiliate controller to update the affiliate rate (in basis point).
     * @param affiliate Affiliate address
     * @param bp Rate (in basis point) to collect (e.g. 100 = 1%) per referred transaction
     */
    updateAffiliateRate(
      affiliate: PromiseOrValue<string>,
      bp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the creator fee manager address.
     * @param newCreatorFeeManager Address of the creator fee manager
     */
    updateCreatorFeeManager(
      newCreatorFeeManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the status of a currency.
     * @param currency Currency address (address(0) for ETH)
     * @param isAllowed Whether the currency should be allowed for trading
     */
    updateCurrencyStatus(
      currency: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * The maximum value that can be set is 25%.      Only callable by owner.
     * This function allows the owner to update the maximum creator fee (in basis point).
     * @param newMaxCreatorFeeBp New maximum creator fee (in basis point)
     */
    updateMaxCreatorFeeBp(
      newMaxCreatorFeeBp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the protocol fee recipient.
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    updateProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update parameters for an existing execution strategy.
     * @param isActive Whether the strategy must be active
     * @param newMinTotalFee New minimum total fee (in basis point)
     * @param newStandardProtocolFee New standard protocol fee (in basis point)
     * @param strategyId Strategy id
     */
    updateStrategy(
      strategyId: PromiseOrValue<BigNumberish>,
      isActive: PromiseOrValue<boolean>,
      newStandardProtocolFee: PromiseOrValue<BigNumberish>,
      newMinTotalFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This tracks the bid and ask nonces for a user address.
     */
    userBidAskNonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { bidNonce: BigNumber; askNonce: BigNumber }
    >;

    /**
     * This checks whether the order nonce for a user was executed or cancelled.
     */
    userOrderNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * This checks whether the subset nonce for a user was cancelled.
     */
    userSubsetNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    executeTakerAsk(
      takerAsk: OrderStructs.TakerStruct,
      makerBid: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeMultipleTakerBids(
      takerBids: OrderStructs.TakerStruct[],
      makerAsks: OrderStructs.MakerStruct[],
      makerSignatures: PromiseOrValue<BytesLike>[],
      merkleTrees: OrderStructs.MerkleTreeStruct[],
      affiliate: PromiseOrValue<string>,
      isAtomic: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    restrictedExecuteTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      sender: PromiseOrValue<string>,
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner. If there is a fork of the network with a new chainId,      it allows the owner to reset the domain separator for the new chain id.
     * This function allows the owner to update the domain separator (if possible).
     */
    updateDomainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the maximum ETH gas limit for a standard transfer.
     * @param newGasLimitETHTransfer New gas limit for ETH transfer
     */
    updateETHGasLimitForTransfer(
      newGasLimitETHTransfer: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  /**
   * Magic value nonce returned if executed (or cancelled).
   */
  MAGIC_VALUE_ORDER_NONCE_EXECUTED(overrides?: CallOverrides): Promise<string>;

  /**
   * Wrapped ETH.
   */
  WETH(overrides?: CallOverrides): Promise<string>;

  /**
   * Strategies have an id that is incremental.      Only callable by owner.
   * This function allows the owner to add a new execution strategy to the protocol.
   * @param implementation Implementation address
   * @param isMakerBid Whether the function selector is for maker bid
   * @param maxProtocolFeeBp Maximum protocol fee (in basis point)
   * @param minTotalFeeBp Minimum total fee (in basis point)
   * @param selector Function selector for the strategy
   * @param standardProtocolFeeBp Standard protocol fee (in basis point)
   */
  addStrategy(
    standardProtocolFeeBp: PromiseOrValue<BigNumberish>,
    minTotalFeeBp: PromiseOrValue<BigNumberish>,
    maxProtocolFeeBp: PromiseOrValue<BigNumberish>,
    selector: PromiseOrValue<BytesLike>,
    isMakerBid: PromiseOrValue<boolean>,
    implementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Address of the affiliate controller.
   */
  affiliateController(overrides?: CallOverrides): Promise<string>;

  /**
   * It tracks the affiliate rate (in basis point) for a given affiliate address.         The basis point represents how much of the protocol fee will be shared to the affiliate.
   */
  affiliateRates(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * It does not check the status of the nonces to save gas      and to prevent revertion if one of the orders is filled in the same      block.
   * This function allows a user to cancel an array of order nonces.
   * @param orderNonces Array of order nonces
   */
  cancelOrderNonces(
    orderNonces: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function can be used for both cancelling a transfer to a new owner and      cancelling the renouncement of the ownership.
   * This function is used to cancel the ownership transfer.
   */
  cancelOwnershipTransfer(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * It does not check the status of the nonces to save gas.
   * This function allows a user to cancel an array of subset nonces.
   * @param subsetNonces Array of subset nonces
   */
  cancelSubsetNonces(
    subsetNonces: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Current chainId.
   */
  chainId(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * This function is used to confirm the ownership renouncement.
   */
  confirmOwnershipRenouncement(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function can only be called by the current potential owner.
   * This function is used to confirm the ownership transfer.
   */
  confirmOwnershipTransfer(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Creator fee manager.
   */
  creatorFeeManager(overrides?: CallOverrides): Promise<string>;

  /**
   * Current domain separator.
   */
  domainSeparator(overrides?: CallOverrides): Promise<string>;

  /**
   * This function returns the hash of the concatenation of batch order type hash and merkle root.
   * @param proofLength Merkle proof length
   * @param root Merkle root
   */
  hashBatchOrder(
    root: PromiseOrValue<BytesLike>,
    proofLength: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * The logic for computing the quasi-random number is inspired by Seaport v1.2.      The pseudo-randomness allows non-deterministic computation of the next ask/bid nonce.      A deterministic increment would make the cancel-all process non-effective in certain cases      (orders signed with a greater ask/bid nonce).      The same quasi-random number is used for incrementing both the bid and ask nonces if both values      are incremented in the same transaction.      If this function is used twice in the same block, it will return the same quasiRandomNumber      but this will not impact the overall business logic.
   * This function increments a user's bid/ask nonces.
   * @param ask Whether to increment the user ask nonce
   * @param bid Whether to increment the user bid nonce
   */
  incrementBidAskNonces(
    bid: PromiseOrValue<boolean>,
    ask: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function is used to initiate the ownership renouncement.
   */
  initiateOwnershipRenouncement(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function is used to initiate the transfer of ownership to a new owner.
   * @param newPotentialOwner New potential owner address
   */
  initiateOwnershipTransfer(
    newPotentialOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Whether the affiliate program is active.
   */
  isAffiliateProgramActive(overrides?: CallOverrides): Promise<boolean>;

  /**
   * It checks whether the currency is allowed for transacting.
   */
  isCurrencyAllowed(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Maximum creator fee (in basis point).
   */
  maxCreatorFeeBp(overrides?: CallOverrides): Promise<number>;

  /**
   * Address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Ownership status.
   */
  ownershipStatus(overrides?: CallOverrides): Promise<number>;

  /**
   * Address of the potential owner.
   */
  potentialOwner(overrides?: CallOverrides): Promise<string>;

  /**
   * Protocol fee recipient.
   */
  protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

  /**
   * This returns the strategy information for a strategy id.
   */
  strategyInfo(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, number, number, number, string, boolean, string] & {
      isActive: boolean;
      standardProtocolFeeBp: number;
      minTotalFeeBp: number;
      maxProtocolFeeBp: number;
      selector: string;
      isMakerBid: boolean;
      implementation: string;
    }
  >;

  /**
   * Transfer manager for ERC721 and ERC1155.
   */
  transferManager(overrides?: CallOverrides): Promise<string>;

  /**
   * Only callable by owner.
   * This function allows the owner to update the affiliate controller address.
   * @param newAffiliateController New affiliate controller address
   */
  updateAffiliateController(
    newAffiliateController: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner.
   * This function allows the owner to update the affiliate program status.
   * @param isActive Whether the affiliate program is active
   */
  updateAffiliateProgramStatus(
    isActive: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function allows the affiliate controller to update the affiliate rate (in basis point).
   * @param affiliate Affiliate address
   * @param bp Rate (in basis point) to collect (e.g. 100 = 1%) per referred transaction
   */
  updateAffiliateRate(
    affiliate: PromiseOrValue<string>,
    bp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner.
   * This function allows the owner to update the creator fee manager address.
   * @param newCreatorFeeManager Address of the creator fee manager
   */
  updateCreatorFeeManager(
    newCreatorFeeManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner.
   * This function allows the owner to update the status of a currency.
   * @param currency Currency address (address(0) for ETH)
   * @param isAllowed Whether the currency should be allowed for trading
   */
  updateCurrencyStatus(
    currency: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * The maximum value that can be set is 25%.      Only callable by owner.
   * This function allows the owner to update the maximum creator fee (in basis point).
   * @param newMaxCreatorFeeBp New maximum creator fee (in basis point)
   */
  updateMaxCreatorFeeBp(
    newMaxCreatorFeeBp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner.
   * This function allows the owner to update the protocol fee recipient.
   * @param newProtocolFeeRecipient New protocol fee recipient address
   */
  updateProtocolFeeRecipient(
    newProtocolFeeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner.
   * This function allows the owner to update parameters for an existing execution strategy.
   * @param isActive Whether the strategy must be active
   * @param newMinTotalFee New minimum total fee (in basis point)
   * @param newStandardProtocolFee New standard protocol fee (in basis point)
   * @param strategyId Strategy id
   */
  updateStrategy(
    strategyId: PromiseOrValue<BigNumberish>,
    isActive: PromiseOrValue<boolean>,
    newStandardProtocolFee: PromiseOrValue<BigNumberish>,
    newMinTotalFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This tracks the bid and ask nonces for a user address.
   */
  userBidAskNonces(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { bidNonce: BigNumber; askNonce: BigNumber }
  >;

  /**
   * This checks whether the order nonce for a user was executed or cancelled.
   */
  userOrderNonce(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * This checks whether the subset nonce for a user was cancelled.
   */
  userSubsetNonce(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  executeTakerAsk(
    takerAsk: OrderStructs.TakerStruct,
    makerBid: OrderStructs.MakerStruct,
    makerSignature: PromiseOrValue<BytesLike>,
    merkleTree: OrderStructs.MerkleTreeStruct,
    affiliate: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeTakerBid(
    takerBid: OrderStructs.TakerStruct,
    makerAsk: OrderStructs.MakerStruct,
    makerSignature: PromiseOrValue<BytesLike>,
    merkleTree: OrderStructs.MerkleTreeStruct,
    affiliate: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeMultipleTakerBids(
    takerBids: OrderStructs.TakerStruct[],
    makerAsks: OrderStructs.MakerStruct[],
    makerSignatures: PromiseOrValue<BytesLike>[],
    merkleTrees: OrderStructs.MerkleTreeStruct[],
    affiliate: PromiseOrValue<string>,
    isAtomic: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  restrictedExecuteTakerBid(
    takerBid: OrderStructs.TakerStruct,
    makerAsk: OrderStructs.MakerStruct,
    sender: PromiseOrValue<string>,
    orderHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner. If there is a fork of the network with a new chainId,      it allows the owner to reset the domain separator for the new chain id.
   * This function allows the owner to update the domain separator (if possible).
   */
  updateDomainSeparator(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by owner.
   * This function allows the owner to update the maximum ETH gas limit for a standard transfer.
   * @param newGasLimitETHTransfer New gas limit for ETH transfer
   */
  updateETHGasLimitForTransfer(
    newGasLimitETHTransfer: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Magic value nonce returned if executed (or cancelled).
     */
    MAGIC_VALUE_ORDER_NONCE_EXECUTED(
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Wrapped ETH.
     */
    WETH(overrides?: CallOverrides): Promise<string>;

    /**
     * Strategies have an id that is incremental.      Only callable by owner.
     * This function allows the owner to add a new execution strategy to the protocol.
     * @param implementation Implementation address
     * @param isMakerBid Whether the function selector is for maker bid
     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)
     * @param minTotalFeeBp Minimum total fee (in basis point)
     * @param selector Function selector for the strategy
     * @param standardProtocolFeeBp Standard protocol fee (in basis point)
     */
    addStrategy(
      standardProtocolFeeBp: PromiseOrValue<BigNumberish>,
      minTotalFeeBp: PromiseOrValue<BigNumberish>,
      maxProtocolFeeBp: PromiseOrValue<BigNumberish>,
      selector: PromiseOrValue<BytesLike>,
      isMakerBid: PromiseOrValue<boolean>,
      implementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Address of the affiliate controller.
     */
    affiliateController(overrides?: CallOverrides): Promise<string>;

    /**
     * It tracks the affiliate rate (in basis point) for a given affiliate address.         The basis point represents how much of the protocol fee will be shared to the affiliate.
     */
    affiliateRates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * It does not check the status of the nonces to save gas      and to prevent revertion if one of the orders is filled in the same      block.
     * This function allows a user to cancel an array of order nonces.
     * @param orderNonces Array of order nonces
     */
    cancelOrderNonces(
      orderNonces: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This function can be used for both cancelling a transfer to a new owner and      cancelling the renouncement of the ownership.
     * This function is used to cancel the ownership transfer.
     */
    cancelOwnershipTransfer(overrides?: CallOverrides): Promise<void>;

    /**
     * It does not check the status of the nonces to save gas.
     * This function allows a user to cancel an array of subset nonces.
     * @param subsetNonces Array of subset nonces
     */
    cancelSubsetNonces(
      subsetNonces: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Current chainId.
     */
    chainId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function is used to confirm the ownership renouncement.
     */
    confirmOwnershipRenouncement(overrides?: CallOverrides): Promise<void>;

    /**
     * This function can only be called by the current potential owner.
     * This function is used to confirm the ownership transfer.
     */
    confirmOwnershipTransfer(overrides?: CallOverrides): Promise<void>;

    /**
     * Creator fee manager.
     */
    creatorFeeManager(overrides?: CallOverrides): Promise<string>;

    /**
     * Current domain separator.
     */
    domainSeparator(overrides?: CallOverrides): Promise<string>;

    /**
     * This function returns the hash of the concatenation of batch order type hash and merkle root.
     * @param proofLength Merkle proof length
     * @param root Merkle root
     */
    hashBatchOrder(
      root: PromiseOrValue<BytesLike>,
      proofLength: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * The logic for computing the quasi-random number is inspired by Seaport v1.2.      The pseudo-randomness allows non-deterministic computation of the next ask/bid nonce.      A deterministic increment would make the cancel-all process non-effective in certain cases      (orders signed with a greater ask/bid nonce).      The same quasi-random number is used for incrementing both the bid and ask nonces if both values      are incremented in the same transaction.      If this function is used twice in the same block, it will return the same quasiRandomNumber      but this will not impact the overall business logic.
     * This function increments a user's bid/ask nonces.
     * @param ask Whether to increment the user ask nonce
     * @param bid Whether to increment the user bid nonce
     */
    incrementBidAskNonces(
      bid: PromiseOrValue<boolean>,
      ask: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This function is used to initiate the ownership renouncement.
     */
    initiateOwnershipRenouncement(overrides?: CallOverrides): Promise<void>;

    /**
     * This function is used to initiate the transfer of ownership to a new owner.
     * @param newPotentialOwner New potential owner address
     */
    initiateOwnershipTransfer(
      newPotentialOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Whether the affiliate program is active.
     */
    isAffiliateProgramActive(overrides?: CallOverrides): Promise<boolean>;

    /**
     * It checks whether the currency is allowed for transacting.
     */
    isCurrencyAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Maximum creator fee (in basis point).
     */
    maxCreatorFeeBp(overrides?: CallOverrides): Promise<number>;

    /**
     * Address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Ownership status.
     */
    ownershipStatus(overrides?: CallOverrides): Promise<number>;

    /**
     * Address of the potential owner.
     */
    potentialOwner(overrides?: CallOverrides): Promise<string>;

    /**
     * Protocol fee recipient.
     */
    protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

    /**
     * This returns the strategy information for a strategy id.
     */
    strategyInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, number, number, number, string, boolean, string] & {
        isActive: boolean;
        standardProtocolFeeBp: number;
        minTotalFeeBp: number;
        maxProtocolFeeBp: number;
        selector: string;
        isMakerBid: boolean;
        implementation: string;
      }
    >;

    /**
     * Transfer manager for ERC721 and ERC1155.
     */
    transferManager(overrides?: CallOverrides): Promise<string>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate controller address.
     * @param newAffiliateController New affiliate controller address
     */
    updateAffiliateController(
      newAffiliateController: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate program status.
     * @param isActive Whether the affiliate program is active
     */
    updateAffiliateProgramStatus(
      isActive: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This function allows the affiliate controller to update the affiliate rate (in basis point).
     * @param affiliate Affiliate address
     * @param bp Rate (in basis point) to collect (e.g. 100 = 1%) per referred transaction
     */
    updateAffiliateRate(
      affiliate: PromiseOrValue<string>,
      bp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the creator fee manager address.
     * @param newCreatorFeeManager Address of the creator fee manager
     */
    updateCreatorFeeManager(
      newCreatorFeeManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the status of a currency.
     * @param currency Currency address (address(0) for ETH)
     * @param isAllowed Whether the currency should be allowed for trading
     */
    updateCurrencyStatus(
      currency: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The maximum value that can be set is 25%.      Only callable by owner.
     * This function allows the owner to update the maximum creator fee (in basis point).
     * @param newMaxCreatorFeeBp New maximum creator fee (in basis point)
     */
    updateMaxCreatorFeeBp(
      newMaxCreatorFeeBp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the protocol fee recipient.
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    updateProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by owner.
     * This function allows the owner to update parameters for an existing execution strategy.
     * @param isActive Whether the strategy must be active
     * @param newMinTotalFee New minimum total fee (in basis point)
     * @param newStandardProtocolFee New standard protocol fee (in basis point)
     * @param strategyId Strategy id
     */
    updateStrategy(
      strategyId: PromiseOrValue<BigNumberish>,
      isActive: PromiseOrValue<boolean>,
      newStandardProtocolFee: PromiseOrValue<BigNumberish>,
      newMinTotalFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This tracks the bid and ask nonces for a user address.
     */
    userBidAskNonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { bidNonce: BigNumber; askNonce: BigNumber }
    >;

    /**
     * This checks whether the order nonce for a user was executed or cancelled.
     */
    userOrderNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * This checks whether the subset nonce for a user was cancelled.
     */
    userSubsetNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executeTakerAsk(
      takerAsk: OrderStructs.TakerStruct,
      makerBid: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeMultipleTakerBids(
      takerBids: OrderStructs.TakerStruct[],
      makerAsks: OrderStructs.MakerStruct[],
      makerSignatures: PromiseOrValue<BytesLike>[],
      merkleTrees: OrderStructs.MerkleTreeStruct[],
      affiliate: PromiseOrValue<string>,
      isAtomic: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    restrictedExecuteTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      sender: PromiseOrValue<string>,
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Only callable by owner. If there is a fork of the network with a new chainId,      it allows the owner to reset the domain separator for the new chain id.
     * This function allows the owner to update the domain separator (if possible).
     */
    updateDomainSeparator(overrides?: CallOverrides): Promise<void>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the maximum ETH gas limit for a standard transfer.
     * @param newGasLimitETHTransfer New gas limit for ETH transfer
     */
    updateETHGasLimitForTransfer(
      newGasLimitETHTransfer: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AffiliatePayment(address,address,uint256)"(
      affiliate?: null,
      currency?: null,
      affiliateFee?: null
    ): AffiliatePaymentEventFilter;
    AffiliatePayment(
      affiliate?: null,
      currency?: null,
      affiliateFee?: null
    ): AffiliatePaymentEventFilter;

    "CancelOwnershipTransfer()"(): CancelOwnershipTransferEventFilter;
    CancelOwnershipTransfer(): CancelOwnershipTransferEventFilter;

    "CurrencyStatusUpdated(address,bool)"(
      currency?: null,
      isAllowed?: null
    ): CurrencyStatusUpdatedEventFilter;
    CurrencyStatusUpdated(
      currency?: null,
      isAllowed?: null
    ): CurrencyStatusUpdatedEventFilter;

    "InitiateOwnershipRenouncement()"(): InitiateOwnershipRenouncementEventFilter;
    InitiateOwnershipRenouncement(): InitiateOwnershipRenouncementEventFilter;

    "InitiateOwnershipTransfer(address,address)"(
      previousOwner?: null,
      potentialOwner?: null
    ): InitiateOwnershipTransferEventFilter;
    InitiateOwnershipTransfer(
      previousOwner?: null,
      potentialOwner?: null
    ): InitiateOwnershipTransferEventFilter;

    "NewAffiliateController(address)"(
      affiliateController?: null
    ): NewAffiliateControllerEventFilter;
    NewAffiliateController(
      affiliateController?: null
    ): NewAffiliateControllerEventFilter;

    "NewAffiliateProgramStatus(bool)"(
      isActive?: null
    ): NewAffiliateProgramStatusEventFilter;
    NewAffiliateProgramStatus(
      isActive?: null
    ): NewAffiliateProgramStatusEventFilter;

    "NewAffiliateRate(address,uint256)"(
      affiliate?: null,
      rate?: null
    ): NewAffiliateRateEventFilter;
    NewAffiliateRate(
      affiliate?: null,
      rate?: null
    ): NewAffiliateRateEventFilter;

    "NewBidAskNonces(address,uint256,uint256)"(
      user?: null,
      bidNonce?: null,
      askNonce?: null
    ): NewBidAskNoncesEventFilter;
    NewBidAskNonces(
      user?: null,
      bidNonce?: null,
      askNonce?: null
    ): NewBidAskNoncesEventFilter;

    "NewCreatorFeeManager(address)"(
      creatorFeeManager?: null
    ): NewCreatorFeeManagerEventFilter;
    NewCreatorFeeManager(
      creatorFeeManager?: null
    ): NewCreatorFeeManagerEventFilter;

    "NewDomainSeparator()"(): NewDomainSeparatorEventFilter;
    NewDomainSeparator(): NewDomainSeparatorEventFilter;

    "NewGasLimitETHTransfer(uint256)"(
      gasLimitETHTransfer?: null
    ): NewGasLimitETHTransferEventFilter;
    NewGasLimitETHTransfer(
      gasLimitETHTransfer?: null
    ): NewGasLimitETHTransferEventFilter;

    "NewMaxCreatorFeeBp(uint256)"(
      maxCreatorFeeBp?: null
    ): NewMaxCreatorFeeBpEventFilter;
    NewMaxCreatorFeeBp(maxCreatorFeeBp?: null): NewMaxCreatorFeeBpEventFilter;

    "NewOwner(address)"(newOwner?: null): NewOwnerEventFilter;
    NewOwner(newOwner?: null): NewOwnerEventFilter;

    "NewProtocolFeeRecipient(address)"(
      protocolFeeRecipient?: null
    ): NewProtocolFeeRecipientEventFilter;
    NewProtocolFeeRecipient(
      protocolFeeRecipient?: null
    ): NewProtocolFeeRecipientEventFilter;

    "NewStrategy(uint256,uint16,uint16,uint16,bytes4,bool,address)"(
      strategyId?: null,
      standardProtocolFeeBp?: null,
      minTotalFeeBp?: null,
      maxProtocolFeeBp?: null,
      selector?: null,
      isMakerBid?: null,
      implementation?: null
    ): NewStrategyEventFilter;
    NewStrategy(
      strategyId?: null,
      standardProtocolFeeBp?: null,
      minTotalFeeBp?: null,
      maxProtocolFeeBp?: null,
      selector?: null,
      isMakerBid?: null,
      implementation?: null
    ): NewStrategyEventFilter;

    "OrderNoncesCancelled(address,uint256[])"(
      user?: null,
      orderNonces?: null
    ): OrderNoncesCancelledEventFilter;
    OrderNoncesCancelled(
      user?: null,
      orderNonces?: null
    ): OrderNoncesCancelledEventFilter;

    "StrategyUpdated(uint256,bool,uint16,uint16)"(
      strategyId?: null,
      isActive?: null,
      standardProtocolFeeBp?: null,
      minTotalFeeBp?: null
    ): StrategyUpdatedEventFilter;
    StrategyUpdated(
      strategyId?: null,
      isActive?: null,
      standardProtocolFeeBp?: null,
      minTotalFeeBp?: null
    ): StrategyUpdatedEventFilter;

    "SubsetNoncesCancelled(address,uint256[])"(
      user?: null,
      subsetNonces?: null
    ): SubsetNoncesCancelledEventFilter;
    SubsetNoncesCancelled(
      user?: null,
      subsetNonces?: null
    ): SubsetNoncesCancelledEventFilter;

    "TakerAsk(tuple,address,address,uint256,address,address,uint256[],uint256[],address[2],uint256[3])"(
      nonceInvalidationParameters?: null,
      askUser?: null,
      bidUser?: null,
      strategyId?: null,
      currency?: null,
      collection?: null,
      itemIds?: null,
      amounts?: null,
      feeRecipients?: null,
      feeAmounts?: null
    ): TakerAskEventFilter;
    TakerAsk(
      nonceInvalidationParameters?: null,
      askUser?: null,
      bidUser?: null,
      strategyId?: null,
      currency?: null,
      collection?: null,
      itemIds?: null,
      amounts?: null,
      feeRecipients?: null,
      feeAmounts?: null
    ): TakerAskEventFilter;

    "TakerBid(tuple,address,address,uint256,address,address,uint256[],uint256[],address[2],uint256[3])"(
      nonceInvalidationParameters?: null,
      bidUser?: null,
      bidRecipient?: null,
      strategyId?: null,
      currency?: null,
      collection?: null,
      itemIds?: null,
      amounts?: null,
      feeRecipients?: null,
      feeAmounts?: null
    ): TakerBidEventFilter;
    TakerBid(
      nonceInvalidationParameters?: null,
      bidUser?: null,
      bidRecipient?: null,
      strategyId?: null,
      currency?: null,
      collection?: null,
      itemIds?: null,
      amounts?: null,
      feeRecipients?: null,
      feeAmounts?: null
    ): TakerBidEventFilter;
  };

  estimateGas: {
    /**
     * Magic value nonce returned if executed (or cancelled).
     */
    MAGIC_VALUE_ORDER_NONCE_EXECUTED(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Wrapped ETH.
     */
    WETH(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Strategies have an id that is incremental.      Only callable by owner.
     * This function allows the owner to add a new execution strategy to the protocol.
     * @param implementation Implementation address
     * @param isMakerBid Whether the function selector is for maker bid
     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)
     * @param minTotalFeeBp Minimum total fee (in basis point)
     * @param selector Function selector for the strategy
     * @param standardProtocolFeeBp Standard protocol fee (in basis point)
     */
    addStrategy(
      standardProtocolFeeBp: PromiseOrValue<BigNumberish>,
      minTotalFeeBp: PromiseOrValue<BigNumberish>,
      maxProtocolFeeBp: PromiseOrValue<BigNumberish>,
      selector: PromiseOrValue<BytesLike>,
      isMakerBid: PromiseOrValue<boolean>,
      implementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Address of the affiliate controller.
     */
    affiliateController(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * It tracks the affiliate rate (in basis point) for a given affiliate address.         The basis point represents how much of the protocol fee will be shared to the affiliate.
     */
    affiliateRates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * It does not check the status of the nonces to save gas      and to prevent revertion if one of the orders is filled in the same      block.
     * This function allows a user to cancel an array of order nonces.
     * @param orderNonces Array of order nonces
     */
    cancelOrderNonces(
      orderNonces: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This function can be used for both cancelling a transfer to a new owner and      cancelling the renouncement of the ownership.
     * This function is used to cancel the ownership transfer.
     */
    cancelOwnershipTransfer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * It does not check the status of the nonces to save gas.
     * This function allows a user to cancel an array of subset nonces.
     * @param subsetNonces Array of subset nonces
     */
    cancelSubsetNonces(
      subsetNonces: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Current chainId.
     */
    chainId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function is used to confirm the ownership renouncement.
     */
    confirmOwnershipRenouncement(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This function can only be called by the current potential owner.
     * This function is used to confirm the ownership transfer.
     */
    confirmOwnershipTransfer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Creator fee manager.
     */
    creatorFeeManager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Current domain separator.
     */
    domainSeparator(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This function returns the hash of the concatenation of batch order type hash and merkle root.
     * @param proofLength Merkle proof length
     * @param root Merkle root
     */
    hashBatchOrder(
      root: PromiseOrValue<BytesLike>,
      proofLength: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The logic for computing the quasi-random number is inspired by Seaport v1.2.      The pseudo-randomness allows non-deterministic computation of the next ask/bid nonce.      A deterministic increment would make the cancel-all process non-effective in certain cases      (orders signed with a greater ask/bid nonce).      The same quasi-random number is used for incrementing both the bid and ask nonces if both values      are incremented in the same transaction.      If this function is used twice in the same block, it will return the same quasiRandomNumber      but this will not impact the overall business logic.
     * This function increments a user's bid/ask nonces.
     * @param ask Whether to increment the user ask nonce
     * @param bid Whether to increment the user bid nonce
     */
    incrementBidAskNonces(
      bid: PromiseOrValue<boolean>,
      ask: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This function is used to initiate the ownership renouncement.
     */
    initiateOwnershipRenouncement(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This function is used to initiate the transfer of ownership to a new owner.
     * @param newPotentialOwner New potential owner address
     */
    initiateOwnershipTransfer(
      newPotentialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Whether the affiliate program is active.
     */
    isAffiliateProgramActive(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * It checks whether the currency is allowed for transacting.
     */
    isCurrencyAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Maximum creator fee (in basis point).
     */
    maxCreatorFeeBp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Ownership status.
     */
    ownershipStatus(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Address of the potential owner.
     */
    potentialOwner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Protocol fee recipient.
     */
    protocolFeeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This returns the strategy information for a strategy id.
     */
    strategyInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Transfer manager for ERC721 and ERC1155.
     */
    transferManager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate controller address.
     * @param newAffiliateController New affiliate controller address
     */
    updateAffiliateController(
      newAffiliateController: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate program status.
     * @param isActive Whether the affiliate program is active
     */
    updateAffiliateProgramStatus(
      isActive: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This function allows the affiliate controller to update the affiliate rate (in basis point).
     * @param affiliate Affiliate address
     * @param bp Rate (in basis point) to collect (e.g. 100 = 1%) per referred transaction
     */
    updateAffiliateRate(
      affiliate: PromiseOrValue<string>,
      bp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the creator fee manager address.
     * @param newCreatorFeeManager Address of the creator fee manager
     */
    updateCreatorFeeManager(
      newCreatorFeeManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the status of a currency.
     * @param currency Currency address (address(0) for ETH)
     * @param isAllowed Whether the currency should be allowed for trading
     */
    updateCurrencyStatus(
      currency: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * The maximum value that can be set is 25%.      Only callable by owner.
     * This function allows the owner to update the maximum creator fee (in basis point).
     * @param newMaxCreatorFeeBp New maximum creator fee (in basis point)
     */
    updateMaxCreatorFeeBp(
      newMaxCreatorFeeBp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the protocol fee recipient.
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    updateProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update parameters for an existing execution strategy.
     * @param isActive Whether the strategy must be active
     * @param newMinTotalFee New minimum total fee (in basis point)
     * @param newStandardProtocolFee New standard protocol fee (in basis point)
     * @param strategyId Strategy id
     */
    updateStrategy(
      strategyId: PromiseOrValue<BigNumberish>,
      isActive: PromiseOrValue<boolean>,
      newStandardProtocolFee: PromiseOrValue<BigNumberish>,
      newMinTotalFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This tracks the bid and ask nonces for a user address.
     */
    userBidAskNonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This checks whether the order nonce for a user was executed or cancelled.
     */
    userOrderNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This checks whether the subset nonce for a user was cancelled.
     */
    userSubsetNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executeTakerAsk(
      takerAsk: OrderStructs.TakerStruct,
      makerBid: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeMultipleTakerBids(
      takerBids: OrderStructs.TakerStruct[],
      makerAsks: OrderStructs.MakerStruct[],
      makerSignatures: PromiseOrValue<BytesLike>[],
      merkleTrees: OrderStructs.MerkleTreeStruct[],
      affiliate: PromiseOrValue<string>,
      isAtomic: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    restrictedExecuteTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      sender: PromiseOrValue<string>,
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner. If there is a fork of the network with a new chainId,      it allows the owner to reset the domain separator for the new chain id.
     * This function allows the owner to update the domain separator (if possible).
     */
    updateDomainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the maximum ETH gas limit for a standard transfer.
     * @param newGasLimitETHTransfer New gas limit for ETH transfer
     */
    updateETHGasLimitForTransfer(
      newGasLimitETHTransfer: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Magic value nonce returned if executed (or cancelled).
     */
    MAGIC_VALUE_ORDER_NONCE_EXECUTED(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Wrapped ETH.
     */
    WETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Strategies have an id that is incremental.      Only callable by owner.
     * This function allows the owner to add a new execution strategy to the protocol.
     * @param implementation Implementation address
     * @param isMakerBid Whether the function selector is for maker bid
     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)
     * @param minTotalFeeBp Minimum total fee (in basis point)
     * @param selector Function selector for the strategy
     * @param standardProtocolFeeBp Standard protocol fee (in basis point)
     */
    addStrategy(
      standardProtocolFeeBp: PromiseOrValue<BigNumberish>,
      minTotalFeeBp: PromiseOrValue<BigNumberish>,
      maxProtocolFeeBp: PromiseOrValue<BigNumberish>,
      selector: PromiseOrValue<BytesLike>,
      isMakerBid: PromiseOrValue<boolean>,
      implementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Address of the affiliate controller.
     */
    affiliateController(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * It tracks the affiliate rate (in basis point) for a given affiliate address.         The basis point represents how much of the protocol fee will be shared to the affiliate.
     */
    affiliateRates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * It does not check the status of the nonces to save gas      and to prevent revertion if one of the orders is filled in the same      block.
     * This function allows a user to cancel an array of order nonces.
     * @param orderNonces Array of order nonces
     */
    cancelOrderNonces(
      orderNonces: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function can be used for both cancelling a transfer to a new owner and      cancelling the renouncement of the ownership.
     * This function is used to cancel the ownership transfer.
     */
    cancelOwnershipTransfer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * It does not check the status of the nonces to save gas.
     * This function allows a user to cancel an array of subset nonces.
     * @param subsetNonces Array of subset nonces
     */
    cancelSubsetNonces(
      subsetNonces: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Current chainId.
     */
    chainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This function is used to confirm the ownership renouncement.
     */
    confirmOwnershipRenouncement(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function can only be called by the current potential owner.
     * This function is used to confirm the ownership transfer.
     */
    confirmOwnershipTransfer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Creator fee manager.
     */
    creatorFeeManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Current domain separator.
     */
    domainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This function returns the hash of the concatenation of batch order type hash and merkle root.
     * @param proofLength Merkle proof length
     * @param root Merkle root
     */
    hashBatchOrder(
      root: PromiseOrValue<BytesLike>,
      proofLength: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The logic for computing the quasi-random number is inspired by Seaport v1.2.      The pseudo-randomness allows non-deterministic computation of the next ask/bid nonce.      A deterministic increment would make the cancel-all process non-effective in certain cases      (orders signed with a greater ask/bid nonce).      The same quasi-random number is used for incrementing both the bid and ask nonces if both values      are incremented in the same transaction.      If this function is used twice in the same block, it will return the same quasiRandomNumber      but this will not impact the overall business logic.
     * This function increments a user's bid/ask nonces.
     * @param ask Whether to increment the user ask nonce
     * @param bid Whether to increment the user bid nonce
     */
    incrementBidAskNonces(
      bid: PromiseOrValue<boolean>,
      ask: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function is used to initiate the ownership renouncement.
     */
    initiateOwnershipRenouncement(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function is used to initiate the transfer of ownership to a new owner.
     * @param newPotentialOwner New potential owner address
     */
    initiateOwnershipTransfer(
      newPotentialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Whether the affiliate program is active.
     */
    isAffiliateProgramActive(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * It checks whether the currency is allowed for transacting.
     */
    isCurrencyAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Maximum creator fee (in basis point).
     */
    maxCreatorFeeBp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Ownership status.
     */
    ownershipStatus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Address of the potential owner.
     */
    potentialOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Protocol fee recipient.
     */
    protocolFeeRecipient(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This returns the strategy information for a strategy id.
     */
    strategyInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer manager for ERC721 and ERC1155.
     */
    transferManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate controller address.
     * @param newAffiliateController New affiliate controller address
     */
    updateAffiliateController(
      newAffiliateController: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the affiliate program status.
     * @param isActive Whether the affiliate program is active
     */
    updateAffiliateProgramStatus(
      isActive: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function allows the affiliate controller to update the affiliate rate (in basis point).
     * @param affiliate Affiliate address
     * @param bp Rate (in basis point) to collect (e.g. 100 = 1%) per referred transaction
     */
    updateAffiliateRate(
      affiliate: PromiseOrValue<string>,
      bp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the creator fee manager address.
     * @param newCreatorFeeManager Address of the creator fee manager
     */
    updateCreatorFeeManager(
      newCreatorFeeManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the status of a currency.
     * @param currency Currency address (address(0) for ETH)
     * @param isAllowed Whether the currency should be allowed for trading
     */
    updateCurrencyStatus(
      currency: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The maximum value that can be set is 25%.      Only callable by owner.
     * This function allows the owner to update the maximum creator fee (in basis point).
     * @param newMaxCreatorFeeBp New maximum creator fee (in basis point)
     */
    updateMaxCreatorFeeBp(
      newMaxCreatorFeeBp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the protocol fee recipient.
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    updateProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update parameters for an existing execution strategy.
     * @param isActive Whether the strategy must be active
     * @param newMinTotalFee New minimum total fee (in basis point)
     * @param newStandardProtocolFee New standard protocol fee (in basis point)
     * @param strategyId Strategy id
     */
    updateStrategy(
      strategyId: PromiseOrValue<BigNumberish>,
      isActive: PromiseOrValue<boolean>,
      newStandardProtocolFee: PromiseOrValue<BigNumberish>,
      newMinTotalFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This tracks the bid and ask nonces for a user address.
     */
    userBidAskNonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This checks whether the order nonce for a user was executed or cancelled.
     */
    userOrderNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This checks whether the subset nonce for a user was cancelled.
     */
    userSubsetNonce(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeTakerAsk(
      takerAsk: OrderStructs.TakerStruct,
      makerBid: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      makerSignature: PromiseOrValue<BytesLike>,
      merkleTree: OrderStructs.MerkleTreeStruct,
      affiliate: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeMultipleTakerBids(
      takerBids: OrderStructs.TakerStruct[],
      makerAsks: OrderStructs.MakerStruct[],
      makerSignatures: PromiseOrValue<BytesLike>[],
      merkleTrees: OrderStructs.MerkleTreeStruct[],
      affiliate: PromiseOrValue<string>,
      isAtomic: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    restrictedExecuteTakerBid(
      takerBid: OrderStructs.TakerStruct,
      makerAsk: OrderStructs.MakerStruct,
      sender: PromiseOrValue<string>,
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner. If there is a fork of the network with a new chainId,      it allows the owner to reset the domain separator for the new chain id.
     * This function allows the owner to update the domain separator (if possible).
     */
    updateDomainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by owner.
     * This function allows the owner to update the maximum ETH gas limit for a standard transfer.
     * @param newGasLimitETHTransfer New gas limit for ETH transfer
     */
    updateETHGasLimitForTransfer(
      newGasLimitETHTransfer: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
