/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface LSSVMPairEnumerableETHInterface extends utils.Interface {
  functions: {
    "assetRecipient()": FunctionFragment;
    "bondingCurve()": FunctionFragment;
    "call(address,bytes)": FunctionFragment;
    "changeAssetRecipient(address)": FunctionFragment;
    "changeDelta(uint128)": FunctionFragment;
    "changeFee(uint96)": FunctionFragment;
    "changeSpotPrice(uint128)": FunctionFragment;
    "delta()": FunctionFragment;
    "factory()": FunctionFragment;
    "fee()": FunctionFragment;
    "getAllHeldIds()": FunctionFragment;
    "getAssetRecipient()": FunctionFragment;
    "getBuyNFTQuote(uint256)": FunctionFragment;
    "getSellNFTQuote(uint256)": FunctionFragment;
    "initialize(address,address,uint128,uint96,uint128)": FunctionFragment;
    "multicall(bytes[],bool)": FunctionFragment;
    "nft()": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "owner()": FunctionFragment;
    "poolType()": FunctionFragment;
    "spotPrice()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "swapNFTsForToken(uint256[],uint256,address,bool,address)": FunctionFragment;
    "swapTokenForAnyNFTs(uint256,uint256,address,bool,address)": FunctionFragment;
    "swapTokenForSpecificNFTs(uint256[],uint256,address,bool,address)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "withdrawAllETH()": FunctionFragment;
    "withdrawERC1155(address,uint256[],uint256[])": FunctionFragment;
    "withdrawERC20(address,uint256)": FunctionFragment;
    "withdrawERC721(address,uint256[])": FunctionFragment;
    "withdrawETH(uint256)": FunctionFragment;
    "pairVariant()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "assetRecipient"
      | "bondingCurve"
      | "call"
      | "changeAssetRecipient"
      | "changeDelta"
      | "changeFee"
      | "changeSpotPrice"
      | "delta"
      | "factory"
      | "fee"
      | "getAllHeldIds"
      | "getAssetRecipient"
      | "getBuyNFTQuote"
      | "getSellNFTQuote"
      | "initialize"
      | "multicall"
      | "nft"
      | "onERC1155BatchReceived"
      | "onERC1155Received"
      | "onERC721Received"
      | "owner"
      | "poolType"
      | "spotPrice"
      | "supportsInterface"
      | "swapNFTsForToken"
      | "swapTokenForAnyNFTs"
      | "swapTokenForSpecificNFTs"
      | "transferOwnership"
      | "withdrawAllETH"
      | "withdrawERC1155"
      | "withdrawERC20"
      | "withdrawERC721"
      | "withdrawETH"
      | "pairVariant"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "assetRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bondingCurve",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "call",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeAssetRecipient",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeDelta",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSpotPrice",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "delta", values?: undefined): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;
  encodeFunctionData(functionFragment: "fee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getAllHeldIds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBuyNFTQuote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSellNFTQuote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: "nft", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "poolType", values?: undefined): string;
  encodeFunctionData(functionFragment: "spotPrice", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNFTsForToken",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokenForAnyNFTs",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokenForSpecificNFTs",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawAllETH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC1155",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC20",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC721",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawETH",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "pairVariant",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "assetRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bondingCurve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "call", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeAssetRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeDelta",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "changeFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSpotPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "delta", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAllHeldIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBuyNFTQuote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSellNFTQuote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nft", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "poolType", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "spotPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNFTsForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapTokenForAnyNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapTokenForSpecificNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawAllETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC1155",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pairVariant",
    data: BytesLike
  ): Result;

  events: {
    "AssetRecipientChange(address)": EventFragment;
    "DeltaUpdate(uint128)": EventFragment;
    "FeeUpdate(uint96)": EventFragment;
    "NFTWithdrawal()": EventFragment;
    "OwnershipTransferred(address)": EventFragment;
    "SpotPriceUpdate(uint128)": EventFragment;
    "SwapNFTInPair()": EventFragment;
    "SwapNFTOutPair()": EventFragment;
    "TokenDeposit(uint256)": EventFragment;
    "TokenWithdrawal(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AssetRecipientChange"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DeltaUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FeeUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTWithdrawal"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SpotPriceUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapNFTInPair"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapNFTOutPair"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenWithdrawal"): EventFragment;
}

export interface AssetRecipientChangeEventObject {
  a: string;
}
export type AssetRecipientChangeEvent = TypedEvent<
  [string],
  AssetRecipientChangeEventObject
>;

export type AssetRecipientChangeEventFilter =
  TypedEventFilter<AssetRecipientChangeEvent>;

export interface DeltaUpdateEventObject {
  newDelta: BigNumber;
}
export type DeltaUpdateEvent = TypedEvent<[BigNumber], DeltaUpdateEventObject>;

export type DeltaUpdateEventFilter = TypedEventFilter<DeltaUpdateEvent>;

export interface FeeUpdateEventObject {
  newFee: BigNumber;
}
export type FeeUpdateEvent = TypedEvent<[BigNumber], FeeUpdateEventObject>;

export type FeeUpdateEventFilter = TypedEventFilter<FeeUpdateEvent>;

export interface NFTWithdrawalEventObject {}
export type NFTWithdrawalEvent = TypedEvent<[], NFTWithdrawalEventObject>;

export type NFTWithdrawalEventFilter = TypedEventFilter<NFTWithdrawalEvent>;

export interface OwnershipTransferredEventObject {
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface SpotPriceUpdateEventObject {
  newSpotPrice: BigNumber;
}
export type SpotPriceUpdateEvent = TypedEvent<
  [BigNumber],
  SpotPriceUpdateEventObject
>;

export type SpotPriceUpdateEventFilter = TypedEventFilter<SpotPriceUpdateEvent>;

export interface SwapNFTInPairEventObject {}
export type SwapNFTInPairEvent = TypedEvent<[], SwapNFTInPairEventObject>;

export type SwapNFTInPairEventFilter = TypedEventFilter<SwapNFTInPairEvent>;

export interface SwapNFTOutPairEventObject {}
export type SwapNFTOutPairEvent = TypedEvent<[], SwapNFTOutPairEventObject>;

export type SwapNFTOutPairEventFilter = TypedEventFilter<SwapNFTOutPairEvent>;

export interface TokenDepositEventObject {
  amount: BigNumber;
}
export type TokenDepositEvent = TypedEvent<
  [BigNumber],
  TokenDepositEventObject
>;

export type TokenDepositEventFilter = TypedEventFilter<TokenDepositEvent>;

export interface TokenWithdrawalEventObject {
  amount: BigNumber;
}
export type TokenWithdrawalEvent = TypedEvent<
  [BigNumber],
  TokenWithdrawalEventObject
>;

export type TokenWithdrawalEventFilter = TypedEventFilter<TokenWithdrawalEvent>;

export interface LSSVMPairEnumerableETH extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LSSVMPairEnumerableETHInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    assetRecipient(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the type of bonding curve that parameterizes the pair
     */
    bondingCurve(
      overrides?: CallOverrides
    ): Promise<[string] & { _bondingCurve: string }>;

    /**
     * Allows the pair to make arbitrary external calls to contracts whitelisted by the protocol. Only callable by the owner.
     * @param data The calldata to pass to the contract
     * @param target The contract to call
     */
    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Changes the address that will receive assets received from trades. Only callable by the owner.
     * @param newRecipient The new asset recipient
     */
    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Updates the delta parameter. Only callable by the owner.
     * @param newDelta The new delta parameter
     */
    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Updates the fee taken by the LP. Only callable by the owner. Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.
     * @param newFee The new LP fee percentage, 18 decimals
     */
    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Updates the selling spot price. Only callable by the owner.
     * @param newSpotPrice The new selling spot price value, in Token
     */
    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    delta(overrides?: CallOverrides): Promise<[BigNumber]>;

    factory(
      overrides?: CallOverrides
    ): Promise<[string] & { _factory: string }>;

    fee(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Returns all NFT IDs held by the pool
     */
    getAllHeldIds(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    /**
     * Returns the address that assets that receives assets when a swap is done with this pair Can be set to another address by the owner, if set to address(0), defaults to the pair's own address
     */
    getAssetRecipient(
      overrides?: CallOverrides
    ): Promise<[string] & { _assetRecipient: string }>;

    /**
     * Used as read function to query the bonding curve for buy pricing info
     * @param numNFTs The number of NFTs to buy from the pair
     */
    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        inputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    /**
     * Used as read function to query the bonding curve for sell pricing info
     * @param numNFTs The number of NFTs to sell to the pair
     */
    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        outputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    /**
     * Only called once by factory to initialize. We verify this by making sure that the current owner is address(0).  The Ownable library we use disallows setting the owner to be address(0), so this condition should only be valid before the first initialize call.
     * Called during pair creation to set initial parameters
     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.
     * @param _delta The initial delta of the bonding curve
     * @param _fee The initial % fee taken, if this is a trade pair
     * @param _owner The owner of the pair
     * @param _spotPrice The initial price to sell an asset into the pair
     */
    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner
     * Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol
     * @param calls The calldata for each call to make
     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail
     */
    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the NFT collection that parameterizes the pair
     */
    nft(overrides?: CallOverrides): Promise<[string] & { _nft: string }>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the pair's type (TOKEN/NFT/TRADE)
     */
    poolType(
      overrides?: CallOverrides
    ): Promise<[number] & { _poolType: number }>;

    spotPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * To compute the amount of token to that will be received, call bondingCurve.getSellInfo.
     * Sends a set of NFTs to the pair in exchange for token
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual amount is less than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to sell to the pair
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     * @param tokenRecipient The recipient of the token output
     */
    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo. This swap function is meant for users who are ID agnostic
     * Sends token to the pair in exchange for any `numNFTs` NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftRecipient The recipient of the NFTs
     * @param numNFTs The number of NFTs to purchase
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo This swap is meant for users who want specific IDs. Also higher chance of reverting if some of the specified IDs leave the pool before the swap goes through.
     * Sends token to the pair in exchange for a specific set of NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to purchase
     * @param nftRecipient The recipient of the NFTs
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the owner.
     * Withdraws all token owned by the pair to the owner address.
     */
    withdrawAllETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.
     * @param a The NFT to transfer
     * @param amounts The amounts of each id to transfer
     * @param ids The NFT ids to transfer
     */
    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).
     * @param a The token to transfer
     * @param amount The amount of tokens to send to the owner
     */
    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * If the NFT is the pair's collection, we also remove it from the id tracking (if the NFT is missing enumerable).
     * Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)
     * @param a The NFT to transfer
     * @param nftIds The list of IDs of the NFTs to send to the owner
     */
    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the owner.
     * Withdraws a specified amount of token owned by the pair to the owner address.
     * @param amount The amount of token to send to the owner. If the pair's balance is less than this value, the transaction will be reverted.
     */
    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the LSSVMPair type
     */
    pairVariant(overrides?: CallOverrides): Promise<[number]>;
  };

  assetRecipient(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the type of bonding curve that parameterizes the pair
   */
  bondingCurve(overrides?: CallOverrides): Promise<string>;

  /**
   * Allows the pair to make arbitrary external calls to contracts whitelisted by the protocol. Only callable by the owner.
   * @param data The calldata to pass to the contract
   * @param target The contract to call
   */
  call(
    target: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Changes the address that will receive assets received from trades. Only callable by the owner.
   * @param newRecipient The new asset recipient
   */
  changeAssetRecipient(
    newRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Updates the delta parameter. Only callable by the owner.
   * @param newDelta The new delta parameter
   */
  changeDelta(
    newDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Updates the fee taken by the LP. Only callable by the owner. Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.
   * @param newFee The new LP fee percentage, 18 decimals
   */
  changeFee(
    newFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Updates the selling spot price. Only callable by the owner.
   * @param newSpotPrice The new selling spot price value, in Token
   */
  changeSpotPrice(
    newSpotPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  delta(overrides?: CallOverrides): Promise<BigNumber>;

  factory(overrides?: CallOverrides): Promise<string>;

  fee(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns all NFT IDs held by the pool
   */
  getAllHeldIds(overrides?: CallOverrides): Promise<BigNumber[]>;

  /**
   * Returns the address that assets that receives assets when a swap is done with this pair Can be set to another address by the owner, if set to address(0), defaults to the pair's own address
   */
  getAssetRecipient(overrides?: CallOverrides): Promise<string>;

  /**
   * Used as read function to query the bonding curve for buy pricing info
   * @param numNFTs The number of NFTs to buy from the pair
   */
  getBuyNFTQuote(
    numNFTs: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
      error: number;
      newSpotPrice: BigNumber;
      newDelta: BigNumber;
      inputAmount: BigNumber;
      protocolFee: BigNumber;
    }
  >;

  /**
   * Used as read function to query the bonding curve for sell pricing info
   * @param numNFTs The number of NFTs to sell to the pair
   */
  getSellNFTQuote(
    numNFTs: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
      error: number;
      newSpotPrice: BigNumber;
      newDelta: BigNumber;
      outputAmount: BigNumber;
      protocolFee: BigNumber;
    }
  >;

  /**
   * Only called once by factory to initialize. We verify this by making sure that the current owner is address(0).  The Ownable library we use disallows setting the owner to be address(0), so this condition should only be valid before the first initialize call.
   * Called during pair creation to set initial parameters
   * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.
   * @param _delta The initial delta of the bonding curve
   * @param _fee The initial % fee taken, if this is a trade pair
   * @param _owner The owner of the pair
   * @param _spotPrice The initial price to sell an asset into the pair
   */
  initialize(
    _owner: PromiseOrValue<string>,
    _assetRecipient: PromiseOrValue<string>,
    _delta: PromiseOrValue<BigNumberish>,
    _fee: PromiseOrValue<BigNumberish>,
    _spotPrice: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner
   * Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol
   * @param calls The calldata for each call to make
   * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail
   */
  multicall(
    calls: PromiseOrValue<BytesLike>[],
    revertOnFail: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the NFT collection that parameterizes the pair
   */
  nft(overrides?: CallOverrides): Promise<string>;

  onERC1155BatchReceived(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>[],
    arg3: PromiseOrValue<BigNumberish>[],
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BigNumberish>,
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the pair's type (TOKEN/NFT/TRADE)
   */
  poolType(overrides?: CallOverrides): Promise<number>;

  spotPrice(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * See {IERC165-supportsInterface}.
   */
  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * To compute the amount of token to that will be received, call bondingCurve.getSellInfo.
   * Sends a set of NFTs to the pair in exchange for token
   * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
   * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual amount is less than this value, the transaction will be reverted.
   * @param nftIds The list of IDs of the NFTs to sell to the pair
   * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
   * @param tokenRecipient The recipient of the token output
   */
  swapNFTsForToken(
    nftIds: PromiseOrValue<BigNumberish>[],
    minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
    tokenRecipient: PromiseOrValue<string>,
    isRouter: PromiseOrValue<boolean>,
    routerCaller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * To compute the amount of token to send, call bondingCurve.getBuyInfo. This swap function is meant for users who are ID agnostic
   * Sends token to the pair in exchange for any `numNFTs` NFTs
   * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
   * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
   * @param nftRecipient The recipient of the NFTs
   * @param numNFTs The number of NFTs to purchase
   * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
   */
  swapTokenForAnyNFTs(
    numNFTs: PromiseOrValue<BigNumberish>,
    maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
    nftRecipient: PromiseOrValue<string>,
    isRouter: PromiseOrValue<boolean>,
    routerCaller: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * To compute the amount of token to send, call bondingCurve.getBuyInfo This swap is meant for users who want specific IDs. Also higher chance of reverting if some of the specified IDs leave the pool before the swap goes through.
   * Sends token to the pair in exchange for a specific set of NFTs
   * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
   * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
   * @param nftIds The list of IDs of the NFTs to purchase
   * @param nftRecipient The recipient of the NFTs
   * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
   */
  swapTokenForSpecificNFTs(
    nftIds: PromiseOrValue<BigNumberish>[],
    maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
    nftRecipient: PromiseOrValue<string>,
    isRouter: PromiseOrValue<boolean>,
    routerCaller: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the owner.
   * Withdraws all token owned by the pair to the owner address.
   */
  withdrawAllETH(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.
   * @param a The NFT to transfer
   * @param amounts The amounts of each id to transfer
   * @param ids The NFT ids to transfer
   */
  withdrawERC1155(
    a: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).
   * @param a The token to transfer
   * @param amount The amount of tokens to send to the owner
   */
  withdrawERC20(
    a: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * If the NFT is the pair's collection, we also remove it from the id tracking (if the NFT is missing enumerable).
   * Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)
   * @param a The NFT to transfer
   * @param nftIds The list of IDs of the NFTs to send to the owner
   */
  withdrawERC721(
    a: PromiseOrValue<string>,
    nftIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the owner.
   * Withdraws a specified amount of token owned by the pair to the owner address.
   * @param amount The amount of token to send to the owner. If the pair's balance is less than this value, the transaction will be reverted.
   */
  withdrawETH(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the LSSVMPair type
   */
  pairVariant(overrides?: CallOverrides): Promise<number>;

  callStatic: {
    assetRecipient(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the type of bonding curve that parameterizes the pair
     */
    bondingCurve(overrides?: CallOverrides): Promise<string>;

    /**
     * Allows the pair to make arbitrary external calls to contracts whitelisted by the protocol. Only callable by the owner.
     * @param data The calldata to pass to the contract
     * @param target The contract to call
     */
    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Changes the address that will receive assets received from trades. Only callable by the owner.
     * @param newRecipient The new asset recipient
     */
    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the delta parameter. Only callable by the owner.
     * @param newDelta The new delta parameter
     */
    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the fee taken by the LP. Only callable by the owner. Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.
     * @param newFee The new LP fee percentage, 18 decimals
     */
    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the selling spot price. Only callable by the owner.
     * @param newSpotPrice The new selling spot price value, in Token
     */
    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    delta(overrides?: CallOverrides): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<string>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns all NFT IDs held by the pool
     */
    getAllHeldIds(overrides?: CallOverrides): Promise<BigNumber[]>;

    /**
     * Returns the address that assets that receives assets when a swap is done with this pair Can be set to another address by the owner, if set to address(0), defaults to the pair's own address
     */
    getAssetRecipient(overrides?: CallOverrides): Promise<string>;

    /**
     * Used as read function to query the bonding curve for buy pricing info
     * @param numNFTs The number of NFTs to buy from the pair
     */
    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        inputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    /**
     * Used as read function to query the bonding curve for sell pricing info
     * @param numNFTs The number of NFTs to sell to the pair
     */
    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        outputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    /**
     * Only called once by factory to initialize. We verify this by making sure that the current owner is address(0).  The Ownable library we use disallows setting the owner to be address(0), so this condition should only be valid before the first initialize call.
     * Called during pair creation to set initial parameters
     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.
     * @param _delta The initial delta of the bonding curve
     * @param _fee The initial % fee taken, if this is a trade pair
     * @param _owner The owner of the pair
     * @param _spotPrice The initial price to sell an asset into the pair
     */
    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner
     * Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol
     * @param calls The calldata for each call to make
     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail
     */
    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the NFT collection that parameterizes the pair
     */
    nft(overrides?: CallOverrides): Promise<string>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the pair's type (TOKEN/NFT/TRADE)
     */
    poolType(overrides?: CallOverrides): Promise<number>;

    spotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * To compute the amount of token to that will be received, call bondingCurve.getSellInfo.
     * Sends a set of NFTs to the pair in exchange for token
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual amount is less than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to sell to the pair
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     * @param tokenRecipient The recipient of the token output
     */
    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo. This swap function is meant for users who are ID agnostic
     * Sends token to the pair in exchange for any `numNFTs` NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftRecipient The recipient of the NFTs
     * @param numNFTs The number of NFTs to purchase
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo This swap is meant for users who want specific IDs. Also higher chance of reverting if some of the specified IDs leave the pool before the swap goes through.
     * Sends token to the pair in exchange for a specific set of NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to purchase
     * @param nftRecipient The recipient of the NFTs
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by the owner.
     * Withdraws all token owned by the pair to the owner address.
     */
    withdrawAllETH(overrides?: CallOverrides): Promise<void>;

    /**
     * Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.
     * @param a The NFT to transfer
     * @param amounts The amounts of each id to transfer
     * @param ids The NFT ids to transfer
     */
    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).
     * @param a The token to transfer
     * @param amount The amount of tokens to send to the owner
     */
    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * If the NFT is the pair's collection, we also remove it from the id tracking (if the NFT is missing enumerable).
     * Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)
     * @param a The NFT to transfer
     * @param nftIds The list of IDs of the NFTs to send to the owner
     */
    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by the owner.
     * Withdraws a specified amount of token owned by the pair to the owner address.
     * @param amount The amount of token to send to the owner. If the pair's balance is less than this value, the transaction will be reverted.
     */
    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the LSSVMPair type
     */
    pairVariant(overrides?: CallOverrides): Promise<number>;
  };

  filters: {
    "AssetRecipientChange(address)"(a?: null): AssetRecipientChangeEventFilter;
    AssetRecipientChange(a?: null): AssetRecipientChangeEventFilter;

    "DeltaUpdate(uint128)"(newDelta?: null): DeltaUpdateEventFilter;
    DeltaUpdate(newDelta?: null): DeltaUpdateEventFilter;

    "FeeUpdate(uint96)"(newFee?: null): FeeUpdateEventFilter;
    FeeUpdate(newFee?: null): FeeUpdateEventFilter;

    "NFTWithdrawal()"(): NFTWithdrawalEventFilter;
    NFTWithdrawal(): NFTWithdrawalEventFilter;

    "OwnershipTransferred(address)"(
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "SpotPriceUpdate(uint128)"(newSpotPrice?: null): SpotPriceUpdateEventFilter;
    SpotPriceUpdate(newSpotPrice?: null): SpotPriceUpdateEventFilter;

    "SwapNFTInPair()"(): SwapNFTInPairEventFilter;
    SwapNFTInPair(): SwapNFTInPairEventFilter;

    "SwapNFTOutPair()"(): SwapNFTOutPairEventFilter;
    SwapNFTOutPair(): SwapNFTOutPairEventFilter;

    "TokenDeposit(uint256)"(amount?: null): TokenDepositEventFilter;
    TokenDeposit(amount?: null): TokenDepositEventFilter;

    "TokenWithdrawal(uint256)"(amount?: null): TokenWithdrawalEventFilter;
    TokenWithdrawal(amount?: null): TokenWithdrawalEventFilter;
  };

  estimateGas: {
    assetRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the type of bonding curve that parameterizes the pair
     */
    bondingCurve(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Allows the pair to make arbitrary external calls to contracts whitelisted by the protocol. Only callable by the owner.
     * @param data The calldata to pass to the contract
     * @param target The contract to call
     */
    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Changes the address that will receive assets received from trades. Only callable by the owner.
     * @param newRecipient The new asset recipient
     */
    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Updates the delta parameter. Only callable by the owner.
     * @param newDelta The new delta parameter
     */
    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Updates the fee taken by the LP. Only callable by the owner. Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.
     * @param newFee The new LP fee percentage, 18 decimals
     */
    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Updates the selling spot price. Only callable by the owner.
     * @param newSpotPrice The new selling spot price value, in Token
     */
    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    delta(overrides?: CallOverrides): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<BigNumber>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns all NFT IDs held by the pool
     */
    getAllHeldIds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address that assets that receives assets when a swap is done with this pair Can be set to another address by the owner, if set to address(0), defaults to the pair's own address
     */
    getAssetRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Used as read function to query the bonding curve for buy pricing info
     * @param numNFTs The number of NFTs to buy from the pair
     */
    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Used as read function to query the bonding curve for sell pricing info
     * @param numNFTs The number of NFTs to sell to the pair
     */
    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Only called once by factory to initialize. We verify this by making sure that the current owner is address(0).  The Ownable library we use disallows setting the owner to be address(0), so this condition should only be valid before the first initialize call.
     * Called during pair creation to set initial parameters
     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.
     * @param _delta The initial delta of the bonding curve
     * @param _fee The initial % fee taken, if this is a trade pair
     * @param _owner The owner of the pair
     * @param _spotPrice The initial price to sell an asset into the pair
     */
    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner
     * Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol
     * @param calls The calldata for each call to make
     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail
     */
    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the NFT collection that parameterizes the pair
     */
    nft(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the pair's type (TOKEN/NFT/TRADE)
     */
    poolType(overrides?: CallOverrides): Promise<BigNumber>;

    spotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * To compute the amount of token to that will be received, call bondingCurve.getSellInfo.
     * Sends a set of NFTs to the pair in exchange for token
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual amount is less than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to sell to the pair
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     * @param tokenRecipient The recipient of the token output
     */
    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo. This swap function is meant for users who are ID agnostic
     * Sends token to the pair in exchange for any `numNFTs` NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftRecipient The recipient of the NFTs
     * @param numNFTs The number of NFTs to purchase
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo This swap is meant for users who want specific IDs. Also higher chance of reverting if some of the specified IDs leave the pool before the swap goes through.
     * Sends token to the pair in exchange for a specific set of NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to purchase
     * @param nftRecipient The recipient of the NFTs
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by the owner.
     * Withdraws all token owned by the pair to the owner address.
     */
    withdrawAllETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.
     * @param a The NFT to transfer
     * @param amounts The amounts of each id to transfer
     * @param ids The NFT ids to transfer
     */
    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).
     * @param a The token to transfer
     * @param amount The amount of tokens to send to the owner
     */
    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * If the NFT is the pair's collection, we also remove it from the id tracking (if the NFT is missing enumerable).
     * Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)
     * @param a The NFT to transfer
     * @param nftIds The list of IDs of the NFTs to send to the owner
     */
    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Only callable by the owner.
     * Withdraws a specified amount of token owned by the pair to the owner address.
     * @param amount The amount of token to send to the owner. If the pair's balance is less than this value, the transaction will be reverted.
     */
    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the LSSVMPair type
     */
    pairVariant(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    assetRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the type of bonding curve that parameterizes the pair
     */
    bondingCurve(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Allows the pair to make arbitrary external calls to contracts whitelisted by the protocol. Only callable by the owner.
     * @param data The calldata to pass to the contract
     * @param target The contract to call
     */
    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Changes the address that will receive assets received from trades. Only callable by the owner.
     * @param newRecipient The new asset recipient
     */
    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the delta parameter. Only callable by the owner.
     * @param newDelta The new delta parameter
     */
    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the fee taken by the LP. Only callable by the owner. Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.
     * @param newFee The new LP fee percentage, 18 decimals
     */
    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the selling spot price. Only callable by the owner.
     * @param newSpotPrice The new selling spot price value, in Token
     */
    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    delta(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    factory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns all NFT IDs held by the pool
     */
    getAllHeldIds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address that assets that receives assets when a swap is done with this pair Can be set to another address by the owner, if set to address(0), defaults to the pair's own address
     */
    getAssetRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Used as read function to query the bonding curve for buy pricing info
     * @param numNFTs The number of NFTs to buy from the pair
     */
    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Used as read function to query the bonding curve for sell pricing info
     * @param numNFTs The number of NFTs to sell to the pair
     */
    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Only called once by factory to initialize. We verify this by making sure that the current owner is address(0).  The Ownable library we use disallows setting the owner to be address(0), so this condition should only be valid before the first initialize call.
     * Called during pair creation to set initial parameters
     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.
     * @param _delta The initial delta of the bonding curve
     * @param _fee The initial % fee taken, if this is a trade pair
     * @param _owner The owner of the pair
     * @param _spotPrice The initial price to sell an asset into the pair
     */
    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner
     * Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol
     * @param calls The calldata for each call to make
     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail
     */
    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the NFT collection that parameterizes the pair
     */
    nft(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the pair's type (TOKEN/NFT/TRADE)
     */
    poolType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    spotPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * To compute the amount of token to that will be received, call bondingCurve.getSellInfo.
     * Sends a set of NFTs to the pair in exchange for token
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual amount is less than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to sell to the pair
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     * @param tokenRecipient The recipient of the token output
     */
    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo. This swap function is meant for users who are ID agnostic
     * Sends token to the pair in exchange for any `numNFTs` NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftRecipient The recipient of the NFTs
     * @param numNFTs The number of NFTs to purchase
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * To compute the amount of token to send, call bondingCurve.getBuyInfo This swap is meant for users who want specific IDs. Also higher chance of reverting if some of the specified IDs leave the pool before the swap goes through.
     * Sends token to the pair in exchange for a specific set of NFTs
     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.
     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual amount is greater than this value, the transaction will be reverted.
     * @param nftIds The list of IDs of the NFTs to purchase
     * @param nftRecipient The recipient of the NFTs
     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.
     */
    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by the owner.
     * Withdraws all token owned by the pair to the owner address.
     */
    withdrawAllETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.
     * @param a The NFT to transfer
     * @param amounts The amounts of each id to transfer
     * @param ids The NFT ids to transfer
     */
    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).
     * @param a The token to transfer
     * @param amount The amount of tokens to send to the owner
     */
    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * If the NFT is the pair's collection, we also remove it from the id tracking (if the NFT is missing enumerable).
     * Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)
     * @param a The NFT to transfer
     * @param nftIds The list of IDs of the NFTs to send to the owner
     */
    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by the owner.
     * Withdraws a specified amount of token owned by the pair to the owner address.
     * @param amount The amount of token to send to the owner. If the pair's balance is less than this value, the transaction will be reverted.
     */
    withdrawETH(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the LSSVMPair type
     */
    pairVariant(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
