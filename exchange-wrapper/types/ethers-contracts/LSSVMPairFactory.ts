/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace LSSVMPairFactory {
  export type CreateERC20PairParamsStruct = {
    token: PromiseOrValue<string>;
    nft: PromiseOrValue<string>;
    bondingCurve: PromiseOrValue<string>;
    assetRecipient: PromiseOrValue<string>;
    poolType: PromiseOrValue<BigNumberish>;
    delta: PromiseOrValue<BigNumberish>;
    fee: PromiseOrValue<BigNumberish>;
    spotPrice: PromiseOrValue<BigNumberish>;
    initialNFTIDs: PromiseOrValue<BigNumberish>[];
    initialTokenBalance: PromiseOrValue<BigNumberish>;
  };

  export type CreateERC20PairParamsStructOutput = [
    string,
    string,
    string,
    string,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[],
    BigNumber
  ] & {
    token: string;
    nft: string;
    bondingCurve: string;
    assetRecipient: string;
    poolType: number;
    delta: BigNumber;
    fee: BigNumber;
    spotPrice: BigNumber;
    initialNFTIDs: BigNumber[];
    initialTokenBalance: BigNumber;
  };
}

export interface LSSVMPairFactoryInterface extends utils.Interface {
  functions: {
    "bondingCurveAllowed(address)": FunctionFragment;
    "callAllowed(address)": FunctionFragment;
    "enumerableERC20Template()": FunctionFragment;
    "enumerableETHTemplate()": FunctionFragment;
    "missingEnumerableERC20Template()": FunctionFragment;
    "missingEnumerableETHTemplate()": FunctionFragment;
    "owner()": FunctionFragment;
    "protocolFeeMultiplier()": FunctionFragment;
    "protocolFeeRecipient()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "routerStatus(address)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "createPairETH(address,address,address,uint8,uint128,uint96,uint128,uint256[])": FunctionFragment;
    "createPairERC20((address,address,address,address,uint8,uint128,uint96,uint128,uint256[],uint256))": FunctionFragment;
    "isPair(address,uint8)": FunctionFragment;
    "withdrawETHProtocolFees()": FunctionFragment;
    "withdrawERC20ProtocolFees(address,uint256)": FunctionFragment;
    "changeProtocolFeeRecipient(address)": FunctionFragment;
    "changeProtocolFeeMultiplier(uint256)": FunctionFragment;
    "setBondingCurveAllowed(address,bool)": FunctionFragment;
    "setCallAllowed(address,bool)": FunctionFragment;
    "setRouterAllowed(address,bool)": FunctionFragment;
    "depositNFTs(address,uint256[],address)": FunctionFragment;
    "depositERC20(address,address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "bondingCurveAllowed"
      | "callAllowed"
      | "enumerableERC20Template"
      | "enumerableETHTemplate"
      | "missingEnumerableERC20Template"
      | "missingEnumerableETHTemplate"
      | "owner"
      | "protocolFeeMultiplier"
      | "protocolFeeRecipient"
      | "renounceOwnership"
      | "routerStatus"
      | "transferOwnership"
      | "createPairETH"
      | "createPairERC20"
      | "isPair"
      | "withdrawETHProtocolFees"
      | "withdrawERC20ProtocolFees"
      | "changeProtocolFeeRecipient"
      | "changeProtocolFeeMultiplier"
      | "setBondingCurveAllowed"
      | "setCallAllowed"
      | "setRouterAllowed"
      | "depositNFTs"
      | "depositERC20"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "bondingCurveAllowed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "callAllowed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enumerableERC20Template",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enumerableETHTemplate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "missingEnumerableERC20Template",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "missingEnumerableETHTemplate",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "protocolFeeMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "routerStatus",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createPairETH",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createPairERC20",
    values: [LSSVMPairFactory.CreateERC20PairParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "isPair",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawETHProtocolFees",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC20ProtocolFees",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeProtocolFeeRecipient",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeProtocolFeeMultiplier",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBondingCurveAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCallAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRouterAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositNFTs",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositERC20",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "bondingCurveAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enumerableERC20Template",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enumerableETHTemplate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "missingEnumerableERC20Template",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "missingEnumerableETHTemplate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routerStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPairETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPairERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isPair", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawETHProtocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC20ProtocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProtocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProtocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBondingCurveAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCallAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRouterAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20",
    data: BytesLike
  ): Result;

  events: {
    "BondingCurveStatusUpdate(address,bool)": EventFragment;
    "CallTargetStatusUpdate(address,bool)": EventFragment;
    "NFTDeposit(address)": EventFragment;
    "NewPair(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ProtocolFeeMultiplierUpdate(uint256)": EventFragment;
    "ProtocolFeeRecipientUpdate(address)": EventFragment;
    "RouterStatusUpdate(address,bool)": EventFragment;
    "TokenDeposit(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BondingCurveStatusUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CallTargetStatusUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPair"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ProtocolFeeMultiplierUpdate"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProtocolFeeRecipientUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouterStatusUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenDeposit"): EventFragment;
}

export interface BondingCurveStatusUpdateEventObject {
  bondingCurve: string;
  isAllowed: boolean;
}
export type BondingCurveStatusUpdateEvent = TypedEvent<
  [string, boolean],
  BondingCurveStatusUpdateEventObject
>;

export type BondingCurveStatusUpdateEventFilter =
  TypedEventFilter<BondingCurveStatusUpdateEvent>;

export interface CallTargetStatusUpdateEventObject {
  target: string;
  isAllowed: boolean;
}
export type CallTargetStatusUpdateEvent = TypedEvent<
  [string, boolean],
  CallTargetStatusUpdateEventObject
>;

export type CallTargetStatusUpdateEventFilter =
  TypedEventFilter<CallTargetStatusUpdateEvent>;

export interface NFTDepositEventObject {
  poolAddress: string;
}
export type NFTDepositEvent = TypedEvent<[string], NFTDepositEventObject>;

export type NFTDepositEventFilter = TypedEventFilter<NFTDepositEvent>;

export interface NewPairEventObject {
  poolAddress: string;
}
export type NewPairEvent = TypedEvent<[string], NewPairEventObject>;

export type NewPairEventFilter = TypedEventFilter<NewPairEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ProtocolFeeMultiplierUpdateEventObject {
  newMultiplier: BigNumber;
}
export type ProtocolFeeMultiplierUpdateEvent = TypedEvent<
  [BigNumber],
  ProtocolFeeMultiplierUpdateEventObject
>;

export type ProtocolFeeMultiplierUpdateEventFilter =
  TypedEventFilter<ProtocolFeeMultiplierUpdateEvent>;

export interface ProtocolFeeRecipientUpdateEventObject {
  recipientAddress: string;
}
export type ProtocolFeeRecipientUpdateEvent = TypedEvent<
  [string],
  ProtocolFeeRecipientUpdateEventObject
>;

export type ProtocolFeeRecipientUpdateEventFilter =
  TypedEventFilter<ProtocolFeeRecipientUpdateEvent>;

export interface RouterStatusUpdateEventObject {
  router: string;
  isAllowed: boolean;
}
export type RouterStatusUpdateEvent = TypedEvent<
  [string, boolean],
  RouterStatusUpdateEventObject
>;

export type RouterStatusUpdateEventFilter =
  TypedEventFilter<RouterStatusUpdateEvent>;

export interface TokenDepositEventObject {
  poolAddress: string;
}
export type TokenDepositEvent = TypedEvent<[string], TokenDepositEventObject>;

export type TokenDepositEventFilter = TypedEventFilter<TokenDepositEvent>;

export interface LSSVMPairFactory extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LSSVMPairFactoryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    bondingCurveAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    callAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    enumerableERC20Template(overrides?: CallOverrides): Promise<[string]>;

    enumerableETHTemplate(overrides?: CallOverrides): Promise<[string]>;

    missingEnumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<[string]>;

    missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    protocolFeeMultiplier(overrides?: CallOverrides): Promise<[BigNumber]>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    routerStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean] & { allowed: boolean; wasEverAllowed: boolean }
    >;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Creates a pair contract using EIP-1167.
     * @param _assetRecipient The address that will receive the assets traders give during trades. If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.
     * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted
     * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.
     * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.
     * @param _initialNFTIDs The list of IDs of NFTs to transfer from the sender to the pair
     * @param _nft The NFT contract of the collection the pair trades
     * @param _poolType TOKEN, NFT, or TRADE
     * @param _spotPrice The initial selling spot price
     */
    createPairETH(
      _nft: PromiseOrValue<string>,
      _bondingCurve: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _poolType: PromiseOrValue<BigNumberish>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      _initialNFTIDs: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createPairERC20(
      params: LSSVMPairFactory.CreateERC20PairParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Checks if an address is a LSSVMPair. Uses the fact that the pairs are EIP-1167 minimal proxies.
     * @param potentialPair The address to check
     * @param variant The pair variant (NFT is enumerable or not, pair uses ETH or ERC20)
     */
    isPair(
      potentialPair: PromiseOrValue<string>,
      variant: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Withdraws the ETH balance to the protocol fee recipient. Only callable by the owner.
     */
    withdrawETHProtocolFees(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws ERC20 tokens to the protocol fee recipient. Only callable by the owner.
     * @param amount The amount of tokens to transfer
     * @param token The token to transfer
     */
    withdrawERC20ProtocolFees(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Changes the protocol fee recipient address. Only callable by the owner.
     * @param _protocolFeeRecipient The new fee recipient
     */
    changeProtocolFeeRecipient(
      _protocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Changes the protocol fee multiplier. Only callable by the owner.
     * @param _protocolFeeMultiplier The new fee multiplier, 18 decimals
     */
    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the whitelist status of a bonding curve contract. Only callable by the owner.
     * @param bondingCurve The bonding curve contract
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setBondingCurveAllowed(
      bondingCurve: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the whitelist status of a contract to be called arbitrarily by a pair. Only callable by the owner.
     * @param isAllowed True to whitelist, false to remove from whitelist
     * @param target The target contract
     */
    setCallAllowed(
      target: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Updates the router whitelist. Only callable by the owner.
     * @param _router The router
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setRouterAllowed(
      _router: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Used to deposit NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)
     */
    depositNFTs(
      _nft: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Used to deposit ERC20s into a pair after creation and emit an event for indexing (if recipient is indeed an ERC20 pair and the token matches)
     */
    depositERC20(
      token: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  bondingCurveAllowed(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callAllowed(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  enumerableERC20Template(overrides?: CallOverrides): Promise<string>;

  enumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

  missingEnumerableERC20Template(overrides?: CallOverrides): Promise<string>;

  missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  protocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  routerStatus(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, boolean] & { allowed: boolean; wasEverAllowed: boolean }
  >;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Creates a pair contract using EIP-1167.
   * @param _assetRecipient The address that will receive the assets traders give during trades. If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.
   * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted
   * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.
   * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.
   * @param _initialNFTIDs The list of IDs of NFTs to transfer from the sender to the pair
   * @param _nft The NFT contract of the collection the pair trades
   * @param _poolType TOKEN, NFT, or TRADE
   * @param _spotPrice The initial selling spot price
   */
  createPairETH(
    _nft: PromiseOrValue<string>,
    _bondingCurve: PromiseOrValue<string>,
    _assetRecipient: PromiseOrValue<string>,
    _poolType: PromiseOrValue<BigNumberish>,
    _delta: PromiseOrValue<BigNumberish>,
    _fee: PromiseOrValue<BigNumberish>,
    _spotPrice: PromiseOrValue<BigNumberish>,
    _initialNFTIDs: PromiseOrValue<BigNumberish>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createPairERC20(
    params: LSSVMPairFactory.CreateERC20PairParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Checks if an address is a LSSVMPair. Uses the fact that the pairs are EIP-1167 minimal proxies.
   * @param potentialPair The address to check
   * @param variant The pair variant (NFT is enumerable or not, pair uses ETH or ERC20)
   */
  isPair(
    potentialPair: PromiseOrValue<string>,
    variant: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Withdraws the ETH balance to the protocol fee recipient. Only callable by the owner.
   */
  withdrawETHProtocolFees(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws ERC20 tokens to the protocol fee recipient. Only callable by the owner.
   * @param amount The amount of tokens to transfer
   * @param token The token to transfer
   */
  withdrawERC20ProtocolFees(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Changes the protocol fee recipient address. Only callable by the owner.
   * @param _protocolFeeRecipient The new fee recipient
   */
  changeProtocolFeeRecipient(
    _protocolFeeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Changes the protocol fee multiplier. Only callable by the owner.
   * @param _protocolFeeMultiplier The new fee multiplier, 18 decimals
   */
  changeProtocolFeeMultiplier(
    _protocolFeeMultiplier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the whitelist status of a bonding curve contract. Only callable by the owner.
   * @param bondingCurve The bonding curve contract
   * @param isAllowed True to whitelist, false to remove from whitelist
   */
  setBondingCurveAllowed(
    bondingCurve: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the whitelist status of a contract to be called arbitrarily by a pair. Only callable by the owner.
   * @param isAllowed True to whitelist, false to remove from whitelist
   * @param target The target contract
   */
  setCallAllowed(
    target: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Updates the router whitelist. Only callable by the owner.
   * @param _router The router
   * @param isAllowed True to whitelist, false to remove from whitelist
   */
  setRouterAllowed(
    _router: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Used to deposit NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)
   */
  depositNFTs(
    _nft: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Used to deposit ERC20s into a pair after creation and emit an event for indexing (if recipient is indeed an ERC20 pair and the token matches)
   */
  depositERC20(
    token: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    bondingCurveAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    callAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    enumerableERC20Template(overrides?: CallOverrides): Promise<string>;

    enumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

    missingEnumerableERC20Template(overrides?: CallOverrides): Promise<string>;

    missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    protocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    routerStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean] & { allowed: boolean; wasEverAllowed: boolean }
    >;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Creates a pair contract using EIP-1167.
     * @param _assetRecipient The address that will receive the assets traders give during trades. If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.
     * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted
     * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.
     * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.
     * @param _initialNFTIDs The list of IDs of NFTs to transfer from the sender to the pair
     * @param _nft The NFT contract of the collection the pair trades
     * @param _poolType TOKEN, NFT, or TRADE
     * @param _spotPrice The initial selling spot price
     */
    createPairETH(
      _nft: PromiseOrValue<string>,
      _bondingCurve: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _poolType: PromiseOrValue<BigNumberish>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      _initialNFTIDs: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<string>;

    createPairERC20(
      params: LSSVMPairFactory.CreateERC20PairParamsStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Checks if an address is a LSSVMPair. Uses the fact that the pairs are EIP-1167 minimal proxies.
     * @param potentialPair The address to check
     * @param variant The pair variant (NFT is enumerable or not, pair uses ETH or ERC20)
     */
    isPair(
      potentialPair: PromiseOrValue<string>,
      variant: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Withdraws the ETH balance to the protocol fee recipient. Only callable by the owner.
     */
    withdrawETHProtocolFees(overrides?: CallOverrides): Promise<void>;

    /**
     * Withdraws ERC20 tokens to the protocol fee recipient. Only callable by the owner.
     * @param amount The amount of tokens to transfer
     * @param token The token to transfer
     */
    withdrawERC20ProtocolFees(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Changes the protocol fee recipient address. Only callable by the owner.
     * @param _protocolFeeRecipient The new fee recipient
     */
    changeProtocolFeeRecipient(
      _protocolFeeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Changes the protocol fee multiplier. Only callable by the owner.
     * @param _protocolFeeMultiplier The new fee multiplier, 18 decimals
     */
    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the whitelist status of a bonding curve contract. Only callable by the owner.
     * @param bondingCurve The bonding curve contract
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setBondingCurveAllowed(
      bondingCurve: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the whitelist status of a contract to be called arbitrarily by a pair. Only callable by the owner.
     * @param isAllowed True to whitelist, false to remove from whitelist
     * @param target The target contract
     */
    setCallAllowed(
      target: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Updates the router whitelist. Only callable by the owner.
     * @param _router The router
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setRouterAllowed(
      _router: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Used to deposit NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)
     */
    depositNFTs(
      _nft: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Used to deposit ERC20s into a pair after creation and emit an event for indexing (if recipient is indeed an ERC20 pair and the token matches)
     */
    depositERC20(
      token: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "BondingCurveStatusUpdate(address,bool)"(
      bondingCurve?: null,
      isAllowed?: null
    ): BondingCurveStatusUpdateEventFilter;
    BondingCurveStatusUpdate(
      bondingCurve?: null,
      isAllowed?: null
    ): BondingCurveStatusUpdateEventFilter;

    "CallTargetStatusUpdate(address,bool)"(
      target?: null,
      isAllowed?: null
    ): CallTargetStatusUpdateEventFilter;
    CallTargetStatusUpdate(
      target?: null,
      isAllowed?: null
    ): CallTargetStatusUpdateEventFilter;

    "NFTDeposit(address)"(poolAddress?: null): NFTDepositEventFilter;
    NFTDeposit(poolAddress?: null): NFTDepositEventFilter;

    "NewPair(address)"(poolAddress?: null): NewPairEventFilter;
    NewPair(poolAddress?: null): NewPairEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "ProtocolFeeMultiplierUpdate(uint256)"(
      newMultiplier?: null
    ): ProtocolFeeMultiplierUpdateEventFilter;
    ProtocolFeeMultiplierUpdate(
      newMultiplier?: null
    ): ProtocolFeeMultiplierUpdateEventFilter;

    "ProtocolFeeRecipientUpdate(address)"(
      recipientAddress?: null
    ): ProtocolFeeRecipientUpdateEventFilter;
    ProtocolFeeRecipientUpdate(
      recipientAddress?: null
    ): ProtocolFeeRecipientUpdateEventFilter;

    "RouterStatusUpdate(address,bool)"(
      router?: null,
      isAllowed?: null
    ): RouterStatusUpdateEventFilter;
    RouterStatusUpdate(
      router?: null,
      isAllowed?: null
    ): RouterStatusUpdateEventFilter;

    "TokenDeposit(address)"(poolAddress?: null): TokenDepositEventFilter;
    TokenDeposit(poolAddress?: null): TokenDepositEventFilter;
  };

  estimateGas: {
    bondingCurveAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    callAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    enumerableERC20Template(overrides?: CallOverrides): Promise<BigNumber>;

    enumerableETHTemplate(overrides?: CallOverrides): Promise<BigNumber>;

    missingEnumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    routerStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Creates a pair contract using EIP-1167.
     * @param _assetRecipient The address that will receive the assets traders give during trades. If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.
     * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted
     * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.
     * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.
     * @param _initialNFTIDs The list of IDs of NFTs to transfer from the sender to the pair
     * @param _nft The NFT contract of the collection the pair trades
     * @param _poolType TOKEN, NFT, or TRADE
     * @param _spotPrice The initial selling spot price
     */
    createPairETH(
      _nft: PromiseOrValue<string>,
      _bondingCurve: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _poolType: PromiseOrValue<BigNumberish>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      _initialNFTIDs: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createPairERC20(
      params: LSSVMPairFactory.CreateERC20PairParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Checks if an address is a LSSVMPair. Uses the fact that the pairs are EIP-1167 minimal proxies.
     * @param potentialPair The address to check
     * @param variant The pair variant (NFT is enumerable or not, pair uses ETH or ERC20)
     */
    isPair(
      potentialPair: PromiseOrValue<string>,
      variant: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Withdraws the ETH balance to the protocol fee recipient. Only callable by the owner.
     */
    withdrawETHProtocolFees(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Withdraws ERC20 tokens to the protocol fee recipient. Only callable by the owner.
     * @param amount The amount of tokens to transfer
     * @param token The token to transfer
     */
    withdrawERC20ProtocolFees(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Changes the protocol fee recipient address. Only callable by the owner.
     * @param _protocolFeeRecipient The new fee recipient
     */
    changeProtocolFeeRecipient(
      _protocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Changes the protocol fee multiplier. Only callable by the owner.
     * @param _protocolFeeMultiplier The new fee multiplier, 18 decimals
     */
    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the whitelist status of a bonding curve contract. Only callable by the owner.
     * @param bondingCurve The bonding curve contract
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setBondingCurveAllowed(
      bondingCurve: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the whitelist status of a contract to be called arbitrarily by a pair. Only callable by the owner.
     * @param isAllowed True to whitelist, false to remove from whitelist
     * @param target The target contract
     */
    setCallAllowed(
      target: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Updates the router whitelist. Only callable by the owner.
     * @param _router The router
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setRouterAllowed(
      _router: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Used to deposit NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)
     */
    depositNFTs(
      _nft: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Used to deposit ERC20s into a pair after creation and emit an event for indexing (if recipient is indeed an ERC20 pair and the token matches)
     */
    depositERC20(
      token: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    bondingCurveAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    callAllowed(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enumerableETHTemplate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    missingEnumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    missingEnumerableETHTemplate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    protocolFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    protocolFeeRecipient(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    routerStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a pair contract using EIP-1167.
     * @param _assetRecipient The address that will receive the assets traders give during trades. If set to address(0), assets will be sent to the pool address. Not available to TRADE pools.
     * @param _bondingCurve The bonding curve for the pair to price NFTs, must be whitelisted
     * @param _delta The delta value used by the bonding curve. The meaning of delta depends on the specific curve.
     * @param _fee The fee taken by the LP in each trade. Can only be non-zero if _poolType is Trade.
     * @param _initialNFTIDs The list of IDs of NFTs to transfer from the sender to the pair
     * @param _nft The NFT contract of the collection the pair trades
     * @param _poolType TOKEN, NFT, or TRADE
     * @param _spotPrice The initial selling spot price
     */
    createPairETH(
      _nft: PromiseOrValue<string>,
      _bondingCurve: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _poolType: PromiseOrValue<BigNumberish>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      _initialNFTIDs: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createPairERC20(
      params: LSSVMPairFactory.CreateERC20PairParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if an address is a LSSVMPair. Uses the fact that the pairs are EIP-1167 minimal proxies.
     * @param potentialPair The address to check
     * @param variant The pair variant (NFT is enumerable or not, pair uses ETH or ERC20)
     */
    isPair(
      potentialPair: PromiseOrValue<string>,
      variant: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws the ETH balance to the protocol fee recipient. Only callable by the owner.
     */
    withdrawETHProtocolFees(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws ERC20 tokens to the protocol fee recipient. Only callable by the owner.
     * @param amount The amount of tokens to transfer
     * @param token The token to transfer
     */
    withdrawERC20ProtocolFees(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Changes the protocol fee recipient address. Only callable by the owner.
     * @param _protocolFeeRecipient The new fee recipient
     */
    changeProtocolFeeRecipient(
      _protocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Changes the protocol fee multiplier. Only callable by the owner.
     * @param _protocolFeeMultiplier The new fee multiplier, 18 decimals
     */
    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the whitelist status of a bonding curve contract. Only callable by the owner.
     * @param bondingCurve The bonding curve contract
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setBondingCurveAllowed(
      bondingCurve: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the whitelist status of a contract to be called arbitrarily by a pair. Only callable by the owner.
     * @param isAllowed True to whitelist, false to remove from whitelist
     * @param target The target contract
     */
    setCallAllowed(
      target: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the router whitelist. Only callable by the owner.
     * @param _router The router
     * @param isAllowed True to whitelist, false to remove from whitelist
     */
    setRouterAllowed(
      _router: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Used to deposit NFTs into a pair after creation and emit an event for indexing (if recipient is indeed a pair)
     */
    depositNFTs(
      _nft: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Used to deposit ERC20s into a pair after creation and emit an event for indexing (if recipient is indeed an ERC20 pair and the token matches)
     */
    depositERC20(
      token: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
