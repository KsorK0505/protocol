/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface WyvernExchangeWithBulkCancellationsInterface
  extends utils.Interface {
  functions: {
    "name()": FunctionFragment;
    "tokenTransferProxy()": FunctionFragment;
    "staticCall(address,bytes,bytes)": FunctionFragment;
    "changeMinimumMakerProtocolFee(uint256)": FunctionFragment;
    "changeMinimumTakerProtocolFee(uint256)": FunctionFragment;
    "guardedArrayReplace(bytes,bytes,bytes)": FunctionFragment;
    "minimumTakerProtocolFee()": FunctionFragment;
    "codename()": FunctionFragment;
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "calculateCurrentPrice_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes)": FunctionFragment;
    "changeProtocolFeeRecipient(address)": FunctionFragment;
    "version()": FunctionFragment;
    "orderCalldataCanMatch(bytes,bytes,bytes,bytes)": FunctionFragment;
    "validateOrder_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes,uint8,bytes32,bytes32)": FunctionFragment;
    "incrementNonce()": FunctionFragment;
    "calculateFinalPrice(uint8,uint8,uint256,uint256,uint256,uint256)": FunctionFragment;
    "protocolFeeRecipient()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "hashOrder_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes)": FunctionFragment;
    "ordersCanMatch_(address[14],uint256[18],uint8[8],bytes,bytes,bytes,bytes,bytes,bytes)": FunctionFragment;
    "approveOrder_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes,bool)": FunctionFragment;
    "registry()": FunctionFragment;
    "minimumMakerProtocolFee()": FunctionFragment;
    "hashToSign_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes)": FunctionFragment;
    "nonces(address)": FunctionFragment;
    "cancelledOrFinalized(bytes32)": FunctionFragment;
    "owner()": FunctionFragment;
    "exchangeToken()": FunctionFragment;
    "cancelOrder_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes,uint8,bytes32,bytes32)": FunctionFragment;
    "atomicMatch_(address[14],uint256[18],uint8[8],bytes,bytes,bytes,bytes,bytes,bytes,uint8[2],bytes32[5])": FunctionFragment;
    "validateOrderParameters_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes)": FunctionFragment;
    "INVERSE_BASIS_POINT()": FunctionFragment;
    "calculateMatchPrice_(address[14],uint256[18],uint8[8],bytes,bytes,bytes,bytes,bytes,bytes)": FunctionFragment;
    "approvedOrders(bytes32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "cancelOrderWithNonce_(address[7],uint256[9],uint8,uint8,uint8,uint8,bytes,bytes,bytes,uint8,bytes32,bytes32,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "name"
      | "tokenTransferProxy"
      | "staticCall"
      | "changeMinimumMakerProtocolFee"
      | "changeMinimumTakerProtocolFee"
      | "guardedArrayReplace"
      | "minimumTakerProtocolFee"
      | "codename"
      | "DOMAIN_SEPARATOR"
      | "calculateCurrentPrice_"
      | "changeProtocolFeeRecipient"
      | "version"
      | "orderCalldataCanMatch"
      | "validateOrder_"
      | "incrementNonce"
      | "calculateFinalPrice"
      | "protocolFeeRecipient"
      | "renounceOwnership"
      | "hashOrder_"
      | "ordersCanMatch_"
      | "approveOrder_"
      | "registry"
      | "minimumMakerProtocolFee"
      | "hashToSign_"
      | "nonces"
      | "cancelledOrFinalized"
      | "owner"
      | "exchangeToken"
      | "cancelOrder_"
      | "atomicMatch_"
      | "validateOrderParameters_"
      | "INVERSE_BASIS_POINT"
      | "calculateMatchPrice_"
      | "approvedOrders"
      | "transferOwnership"
      | "cancelOrderWithNonce_"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tokenTransferProxy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "staticCall",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeMinimumMakerProtocolFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeMinimumTakerProtocolFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "guardedArrayReplace",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "minimumTakerProtocolFee",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "codename", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateCurrentPrice_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeProtocolFeeRecipient",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "orderCalldataCanMatch",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "validateOrder_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateFinalPrice",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hashOrder_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "ordersCanMatch_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "approveOrder_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(functionFragment: "registry", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "minimumMakerProtocolFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hashToSign_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "nonces",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelledOrFinalized",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "exchangeToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "atomicMatch_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "validateOrderParameters_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "INVERSE_BASIS_POINT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateMatchPrice_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "approvedOrders",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrderWithNonce_",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenTransferProxy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "staticCall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeMinimumMakerProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeMinimumTakerProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "guardedArrayReplace",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minimumTakerProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "codename", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateCurrentPrice_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProtocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "orderCalldataCanMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateOrder_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateFinalPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hashOrder_", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ordersCanMatch_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveOrder_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "registry", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "minimumMakerProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hashToSign_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelledOrFinalized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "exchangeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "atomicMatch_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateOrderParameters_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "INVERSE_BASIS_POINT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateMatchPrice_",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approvedOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrderWithNonce_",
    data: BytesLike
  ): Result;

  events: {
    "OrderApprovedPartOne(bytes32,address,address,address,uint256,uint256,uint256,uint256,address,uint8,uint8,uint8,address)": EventFragment;
    "OrderApprovedPartTwo(bytes32,uint8,bytes,bytes,address,bytes,address,uint256,uint256,uint256,uint256,uint256,bool)": EventFragment;
    "OrderCancelled(bytes32)": EventFragment;
    "OrdersMatched(bytes32,bytes32,address,address,uint256,bytes32)": EventFragment;
    "NonceIncremented(address,uint256)": EventFragment;
    "OwnershipRenounced(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OrderApprovedPartOne"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderApprovedPartTwo"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrdersMatched"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NonceIncremented"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipRenounced"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface OrderApprovedPartOneEventObject {
  hash: string;
  exchange: string;
  maker: string;
  taker: string;
  makerRelayerFee: BigNumber;
  takerRelayerFee: BigNumber;
  makerProtocolFee: BigNumber;
  takerProtocolFee: BigNumber;
  feeRecipient: string;
  feeMethod: number;
  side: number;
  saleKind: number;
  target: string;
}
export type OrderApprovedPartOneEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    number,
    number,
    number,
    string
  ],
  OrderApprovedPartOneEventObject
>;

export type OrderApprovedPartOneEventFilter =
  TypedEventFilter<OrderApprovedPartOneEvent>;

export interface OrderApprovedPartTwoEventObject {
  hash: string;
  howToCall: number;
  calldata: string;
  replacementPattern: string;
  staticTarget: string;
  staticExtradata: string;
  paymentToken: string;
  basePrice: BigNumber;
  extra: BigNumber;
  listingTime: BigNumber;
  expirationTime: BigNumber;
  salt: BigNumber;
  orderbookInclusionDesired: boolean;
}
export type OrderApprovedPartTwoEvent = TypedEvent<
  [
    string,
    number,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ],
  OrderApprovedPartTwoEventObject
>;

export type OrderApprovedPartTwoEventFilter =
  TypedEventFilter<OrderApprovedPartTwoEvent>;

export interface OrderCancelledEventObject {
  hash: string;
}
export type OrderCancelledEvent = TypedEvent<
  [string],
  OrderCancelledEventObject
>;

export type OrderCancelledEventFilter = TypedEventFilter<OrderCancelledEvent>;

export interface OrdersMatchedEventObject {
  buyHash: string;
  sellHash: string;
  maker: string;
  taker: string;
  price: BigNumber;
  metadata: string;
}
export type OrdersMatchedEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  OrdersMatchedEventObject
>;

export type OrdersMatchedEventFilter = TypedEventFilter<OrdersMatchedEvent>;

export interface NonceIncrementedEventObject {
  maker: string;
  newNonce: BigNumber;
}
export type NonceIncrementedEvent = TypedEvent<
  [string, BigNumber],
  NonceIncrementedEventObject
>;

export type NonceIncrementedEventFilter =
  TypedEventFilter<NonceIncrementedEvent>;

export interface OwnershipRenouncedEventObject {
  previousOwner: string;
}
export type OwnershipRenouncedEvent = TypedEvent<
  [string],
  OwnershipRenouncedEventObject
>;

export type OwnershipRenouncedEventFilter =
  TypedEventFilter<OwnershipRenouncedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface WyvernExchangeWithBulkCancellations extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: WyvernExchangeWithBulkCancellationsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    name(overrides?: CallOverrides): Promise<[string]>;

    tokenTransferProxy(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)
     * @param calldata Calldata (appended to extradata)
     * @param extradata Base data for STATICCALL (probably function selector and argument encoding)
     * @param target Contract to call
     * @returns The result of the call (success or failure)
     */
    staticCall(
      target: PromiseOrValue<string>,
      calldata: PromiseOrValue<BytesLike>,
      extradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { result: boolean }>;

    /**
     * Change the minimum maker fee paid to the protocol (owner only)
     * @param newMinimumMakerProtocolFee New fee to set in basis points
     */
    changeMinimumMakerProtocolFee(
      newMinimumMakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Change the minimum taker fee paid to the protocol (owner only)
     * @param newMinimumTakerProtocolFee New fee to set in basis points
     */
    changeMinimumTakerProtocolFee(
      newMinimumTakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call guardedArrayReplace - library function exposed for testing.
     */
    guardedArrayReplace(
      array: PromiseOrValue<BytesLike>,
      desired: PromiseOrValue<BytesLike>,
      mask: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    minimumTakerProtocolFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    codename(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateCurrentPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Change the protocol fee recipient (owner only)
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    changeProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Return whether or not two orders' calldata specifications can match
     * @param buyCalldata Buy-side order calldata
     * @param buyReplacementPattern Buy-side order calldata replacement mask
     * @param sellCalldata Sell-side order calldata
     * @param sellReplacementPattern Sell-side order calldata replacement mask
     * @returns Whether the orders' calldata can be matched
     */
    orderCalldataCanMatch(
      buyCalldata: PromiseOrValue<BytesLike>,
      buyReplacementPattern: PromiseOrValue<BytesLike>,
      sellCalldata: PromiseOrValue<BytesLike>,
      sellReplacementPattern: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed with the original nonce.
     */
    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call calculateFinalPrice - library function exposed for testing.
     */
    calculateFinalPrice(
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      extra: PromiseOrValue<BigNumberish>,
      listingTime: PromiseOrValue<BigNumberish>,
      expirationTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Allows the current owner to relinquish control of the contract.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    ordersCanMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    approveOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      orderbookInclusionDesired: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registry(overrides?: CallOverrides): Promise<[string]>;

    minimumMakerProtocolFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Call hashToSign - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashToSign_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    cancelledOrFinalized(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    exchangeToken(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    cancelOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    atomicMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      vs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      rssMetadata: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call validateOrderParameters - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrderParameters_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateMatchPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Determine if an order has been approved. Note that the order may not still be valid in cases where the maker's nonce has been incremented.
     * @param hash Hash of the order
     * @returns whether or not the order was approved.
     */
    approvedOrders(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { approved: boolean }>;

    /**
     * Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call cancelOrder, supplying a specific nonce — enables cancelling orders that were signed with nonces greater than the current nonce.
     */
    cancelOrderWithNonce_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  name(overrides?: CallOverrides): Promise<string>;

  tokenTransferProxy(overrides?: CallOverrides): Promise<string>;

  /**
   * Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)
   * @param calldata Calldata (appended to extradata)
   * @param extradata Base data for STATICCALL (probably function selector and argument encoding)
   * @param target Contract to call
   * @returns The result of the call (success or failure)
   */
  staticCall(
    target: PromiseOrValue<string>,
    calldata: PromiseOrValue<BytesLike>,
    extradata: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Change the minimum maker fee paid to the protocol (owner only)
   * @param newMinimumMakerProtocolFee New fee to set in basis points
   */
  changeMinimumMakerProtocolFee(
    newMinimumMakerProtocolFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Change the minimum taker fee paid to the protocol (owner only)
   * @param newMinimumTakerProtocolFee New fee to set in basis points
   */
  changeMinimumTakerProtocolFee(
    newMinimumTakerProtocolFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call guardedArrayReplace - library function exposed for testing.
   */
  guardedArrayReplace(
    array: PromiseOrValue<BytesLike>,
    desired: PromiseOrValue<BytesLike>,
    mask: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  minimumTakerProtocolFee(overrides?: CallOverrides): Promise<BigNumber>;

  codename(overrides?: CallOverrides): Promise<string>;

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  /**
   * Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  calculateCurrentPrice_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Change the protocol fee recipient (owner only)
   * @param newProtocolFeeRecipient New protocol fee recipient address
   */
  changeProtocolFeeRecipient(
    newProtocolFeeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<string>;

  /**
   * Return whether or not two orders' calldata specifications can match
   * @param buyCalldata Buy-side order calldata
   * @param buyReplacementPattern Buy-side order calldata replacement mask
   * @param sellCalldata Sell-side order calldata
   * @param sellReplacementPattern Sell-side order calldata replacement mask
   * @returns Whether the orders' calldata can be matched
   */
  orderCalldataCanMatch(
    buyCalldata: PromiseOrValue<BytesLike>,
    buyReplacementPattern: PromiseOrValue<BytesLike>,
    sellCalldata: PromiseOrValue<BytesLike>,
    sellReplacementPattern: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  validateOrder_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Increment a particular maker's nonce, thereby invalidating all orders that were not signed with the original nonce.
   */
  incrementNonce(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call calculateFinalPrice - library function exposed for testing.
   */
  calculateFinalPrice(
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    basePrice: PromiseOrValue<BigNumberish>,
    extra: PromiseOrValue<BigNumberish>,
    listingTime: PromiseOrValue<BigNumberish>,
    expirationTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

  /**
   * Allows the current owner to relinquish control of the contract.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  hashOrder_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  ordersCanMatch_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
    calldataBuy: PromiseOrValue<BytesLike>,
    calldataSell: PromiseOrValue<BytesLike>,
    replacementPatternBuy: PromiseOrValue<BytesLike>,
    replacementPatternSell: PromiseOrValue<BytesLike>,
    staticExtradataBuy: PromiseOrValue<BytesLike>,
    staticExtradataSell: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  approveOrder_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    orderbookInclusionDesired: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registry(overrides?: CallOverrides): Promise<string>;

  minimumMakerProtocolFee(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Call hashToSign - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  hashToSign_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  nonces(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  cancelledOrFinalized(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  exchangeToken(overrides?: CallOverrides): Promise<string>;

  /**
   * Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  cancelOrder_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  atomicMatch_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
    calldataBuy: PromiseOrValue<BytesLike>,
    calldataSell: PromiseOrValue<BytesLike>,
    replacementPatternBuy: PromiseOrValue<BytesLike>,
    replacementPatternSell: PromiseOrValue<BytesLike>,
    staticExtradataBuy: PromiseOrValue<BytesLike>,
    staticExtradataSell: PromiseOrValue<BytesLike>,
    vs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    rssMetadata: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call validateOrderParameters - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  validateOrderParameters_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
   */
  calculateMatchPrice_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
    calldataBuy: PromiseOrValue<BytesLike>,
    calldataSell: PromiseOrValue<BytesLike>,
    replacementPatternBuy: PromiseOrValue<BytesLike>,
    replacementPatternSell: PromiseOrValue<BytesLike>,
    staticExtradataBuy: PromiseOrValue<BytesLike>,
    staticExtradataSell: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Determine if an order has been approved. Note that the order may not still be valid in cases where the maker's nonce has been incremented.
   * @param hash Hash of the order
   * @returns whether or not the order was approved.
   */
  approvedOrders(
    hash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call cancelOrder, supplying a specific nonce — enables cancelling orders that were signed with nonces greater than the current nonce.
   */
  cancelOrderWithNonce_(
    addrs: PromiseOrValue<string>[],
    uints: PromiseOrValue<BigNumberish>[],
    feeMethod: PromiseOrValue<BigNumberish>,
    side: PromiseOrValue<BigNumberish>,
    saleKind: PromiseOrValue<BigNumberish>,
    howToCall: PromiseOrValue<BigNumberish>,
    calldata: PromiseOrValue<BytesLike>,
    replacementPattern: PromiseOrValue<BytesLike>,
    staticExtradata: PromiseOrValue<BytesLike>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    nonce: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    name(overrides?: CallOverrides): Promise<string>;

    tokenTransferProxy(overrides?: CallOverrides): Promise<string>;

    /**
     * Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)
     * @param calldata Calldata (appended to extradata)
     * @param extradata Base data for STATICCALL (probably function selector and argument encoding)
     * @param target Contract to call
     * @returns The result of the call (success or failure)
     */
    staticCall(
      target: PromiseOrValue<string>,
      calldata: PromiseOrValue<BytesLike>,
      extradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Change the minimum maker fee paid to the protocol (owner only)
     * @param newMinimumMakerProtocolFee New fee to set in basis points
     */
    changeMinimumMakerProtocolFee(
      newMinimumMakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Change the minimum taker fee paid to the protocol (owner only)
     * @param newMinimumTakerProtocolFee New fee to set in basis points
     */
    changeMinimumTakerProtocolFee(
      newMinimumTakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Call guardedArrayReplace - library function exposed for testing.
     */
    guardedArrayReplace(
      array: PromiseOrValue<BytesLike>,
      desired: PromiseOrValue<BytesLike>,
      mask: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    minimumTakerProtocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    codename(overrides?: CallOverrides): Promise<string>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    /**
     * Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateCurrentPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Change the protocol fee recipient (owner only)
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    changeProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    version(overrides?: CallOverrides): Promise<string>;

    /**
     * Return whether or not two orders' calldata specifications can match
     * @param buyCalldata Buy-side order calldata
     * @param buyReplacementPattern Buy-side order calldata replacement mask
     * @param sellCalldata Sell-side order calldata
     * @param sellReplacementPattern Sell-side order calldata replacement mask
     * @returns Whether the orders' calldata can be matched
     */
    orderCalldataCanMatch(
      buyCalldata: PromiseOrValue<BytesLike>,
      buyReplacementPattern: PromiseOrValue<BytesLike>,
      sellCalldata: PromiseOrValue<BytesLike>,
      sellReplacementPattern: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed with the original nonce.
     */
    incrementNonce(overrides?: CallOverrides): Promise<void>;

    /**
     * Call calculateFinalPrice - library function exposed for testing.
     */
    calculateFinalPrice(
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      extra: PromiseOrValue<BigNumberish>,
      listingTime: PromiseOrValue<BigNumberish>,
      expirationTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

    /**
     * Allows the current owner to relinquish control of the contract.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    ordersCanMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    approveOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      orderbookInclusionDesired: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    registry(overrides?: CallOverrides): Promise<string>;

    minimumMakerProtocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Call hashToSign - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashToSign_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelledOrFinalized(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    exchangeToken(overrides?: CallOverrides): Promise<string>;

    /**
     * Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    cancelOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    atomicMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      vs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      rssMetadata: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Call validateOrderParameters - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrderParameters_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateMatchPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Determine if an order has been approved. Note that the order may not still be valid in cases where the maker's nonce has been incremented.
     * @param hash Hash of the order
     * @returns whether or not the order was approved.
     */
    approvedOrders(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Call cancelOrder, supplying a specific nonce — enables cancelling orders that were signed with nonces greater than the current nonce.
     */
    cancelOrderWithNonce_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "OrderApprovedPartOne(bytes32,address,address,address,uint256,uint256,uint256,uint256,address,uint8,uint8,uint8,address)"(
      hash?: PromiseOrValue<BytesLike> | null,
      exchange?: null,
      maker?: PromiseOrValue<string> | null,
      taker?: null,
      makerRelayerFee?: null,
      takerRelayerFee?: null,
      makerProtocolFee?: null,
      takerProtocolFee?: null,
      feeRecipient?: PromiseOrValue<string> | null,
      feeMethod?: null,
      side?: null,
      saleKind?: null,
      target?: null
    ): OrderApprovedPartOneEventFilter;
    OrderApprovedPartOne(
      hash?: PromiseOrValue<BytesLike> | null,
      exchange?: null,
      maker?: PromiseOrValue<string> | null,
      taker?: null,
      makerRelayerFee?: null,
      takerRelayerFee?: null,
      makerProtocolFee?: null,
      takerProtocolFee?: null,
      feeRecipient?: PromiseOrValue<string> | null,
      feeMethod?: null,
      side?: null,
      saleKind?: null,
      target?: null
    ): OrderApprovedPartOneEventFilter;

    "OrderApprovedPartTwo(bytes32,uint8,bytes,bytes,address,bytes,address,uint256,uint256,uint256,uint256,uint256,bool)"(
      hash?: PromiseOrValue<BytesLike> | null,
      howToCall?: null,
      calldata?: null,
      replacementPattern?: null,
      staticTarget?: null,
      staticExtradata?: null,
      paymentToken?: null,
      basePrice?: null,
      extra?: null,
      listingTime?: null,
      expirationTime?: null,
      salt?: null,
      orderbookInclusionDesired?: null
    ): OrderApprovedPartTwoEventFilter;
    OrderApprovedPartTwo(
      hash?: PromiseOrValue<BytesLike> | null,
      howToCall?: null,
      calldata?: null,
      replacementPattern?: null,
      staticTarget?: null,
      staticExtradata?: null,
      paymentToken?: null,
      basePrice?: null,
      extra?: null,
      listingTime?: null,
      expirationTime?: null,
      salt?: null,
      orderbookInclusionDesired?: null
    ): OrderApprovedPartTwoEventFilter;

    "OrderCancelled(bytes32)"(
      hash?: PromiseOrValue<BytesLike> | null
    ): OrderCancelledEventFilter;
    OrderCancelled(
      hash?: PromiseOrValue<BytesLike> | null
    ): OrderCancelledEventFilter;

    "OrdersMatched(bytes32,bytes32,address,address,uint256,bytes32)"(
      buyHash?: null,
      sellHash?: null,
      maker?: PromiseOrValue<string> | null,
      taker?: PromiseOrValue<string> | null,
      price?: null,
      metadata?: PromiseOrValue<BytesLike> | null
    ): OrdersMatchedEventFilter;
    OrdersMatched(
      buyHash?: null,
      sellHash?: null,
      maker?: PromiseOrValue<string> | null,
      taker?: PromiseOrValue<string> | null,
      price?: null,
      metadata?: PromiseOrValue<BytesLike> | null
    ): OrdersMatchedEventFilter;

    "NonceIncremented(address,uint256)"(
      maker?: PromiseOrValue<string> | null,
      newNonce?: null
    ): NonceIncrementedEventFilter;
    NonceIncremented(
      maker?: PromiseOrValue<string> | null,
      newNonce?: null
    ): NonceIncrementedEventFilter;

    "OwnershipRenounced(address)"(
      previousOwner?: PromiseOrValue<string> | null
    ): OwnershipRenouncedEventFilter;
    OwnershipRenounced(
      previousOwner?: PromiseOrValue<string> | null
    ): OwnershipRenouncedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    name(overrides?: CallOverrides): Promise<BigNumber>;

    tokenTransferProxy(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)
     * @param calldata Calldata (appended to extradata)
     * @param extradata Base data for STATICCALL (probably function selector and argument encoding)
     * @param target Contract to call
     * @returns The result of the call (success or failure)
     */
    staticCall(
      target: PromiseOrValue<string>,
      calldata: PromiseOrValue<BytesLike>,
      extradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Change the minimum maker fee paid to the protocol (owner only)
     * @param newMinimumMakerProtocolFee New fee to set in basis points
     */
    changeMinimumMakerProtocolFee(
      newMinimumMakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Change the minimum taker fee paid to the protocol (owner only)
     * @param newMinimumTakerProtocolFee New fee to set in basis points
     */
    changeMinimumTakerProtocolFee(
      newMinimumTakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call guardedArrayReplace - library function exposed for testing.
     */
    guardedArrayReplace(
      array: PromiseOrValue<BytesLike>,
      desired: PromiseOrValue<BytesLike>,
      mask: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumTakerProtocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    codename(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateCurrentPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Change the protocol fee recipient (owner only)
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    changeProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return whether or not two orders' calldata specifications can match
     * @param buyCalldata Buy-side order calldata
     * @param buyReplacementPattern Buy-side order calldata replacement mask
     * @param sellCalldata Sell-side order calldata
     * @param sellReplacementPattern Sell-side order calldata replacement mask
     * @returns Whether the orders' calldata can be matched
     */
    orderCalldataCanMatch(
      buyCalldata: PromiseOrValue<BytesLike>,
      buyReplacementPattern: PromiseOrValue<BytesLike>,
      sellCalldata: PromiseOrValue<BytesLike>,
      sellReplacementPattern: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed with the original nonce.
     */
    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call calculateFinalPrice - library function exposed for testing.
     */
    calculateFinalPrice(
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      extra: PromiseOrValue<BigNumberish>,
      listingTime: PromiseOrValue<BigNumberish>,
      expirationTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Allows the current owner to relinquish control of the contract.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    ordersCanMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    approveOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      orderbookInclusionDesired: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registry(overrides?: CallOverrides): Promise<BigNumber>;

    minimumMakerProtocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Call hashToSign - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashToSign_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelledOrFinalized(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    exchangeToken(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    cancelOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    atomicMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      vs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      rssMetadata: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call validateOrderParameters - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrderParameters_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateMatchPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Determine if an order has been approved. Note that the order may not still be valid in cases where the maker's nonce has been incremented.
     * @param hash Hash of the order
     * @returns whether or not the order was approved.
     */
    approvedOrders(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call cancelOrder, supplying a specific nonce — enables cancelling orders that were signed with nonces greater than the current nonce.
     */
    cancelOrderWithNonce_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenTransferProxy(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)
     * @param calldata Calldata (appended to extradata)
     * @param extradata Base data for STATICCALL (probably function selector and argument encoding)
     * @param target Contract to call
     * @returns The result of the call (success or failure)
     */
    staticCall(
      target: PromiseOrValue<string>,
      calldata: PromiseOrValue<BytesLike>,
      extradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Change the minimum maker fee paid to the protocol (owner only)
     * @param newMinimumMakerProtocolFee New fee to set in basis points
     */
    changeMinimumMakerProtocolFee(
      newMinimumMakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Change the minimum taker fee paid to the protocol (owner only)
     * @param newMinimumTakerProtocolFee New fee to set in basis points
     */
    changeMinimumTakerProtocolFee(
      newMinimumTakerProtocolFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call guardedArrayReplace - library function exposed for testing.
     */
    guardedArrayReplace(
      array: PromiseOrValue<BytesLike>,
      desired: PromiseOrValue<BytesLike>,
      mask: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minimumTakerProtocolFee(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    codename(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateCurrentPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Change the protocol fee recipient (owner only)
     * @param newProtocolFeeRecipient New protocol fee recipient address
     */
    changeProtocolFeeRecipient(
      newProtocolFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return whether or not two orders' calldata specifications can match
     * @param buyCalldata Buy-side order calldata
     * @param buyReplacementPattern Buy-side order calldata replacement mask
     * @param sellCalldata Sell-side order calldata
     * @param sellReplacementPattern Sell-side order calldata replacement mask
     * @returns Whether the orders' calldata can be matched
     */
    orderCalldataCanMatch(
      buyCalldata: PromiseOrValue<BytesLike>,
      buyReplacementPattern: PromiseOrValue<BytesLike>,
      sellCalldata: PromiseOrValue<BytesLike>,
      sellReplacementPattern: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed with the original nonce.
     */
    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call calculateFinalPrice - library function exposed for testing.
     */
    calculateFinalPrice(
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      extra: PromiseOrValue<BigNumberish>,
      listingTime: PromiseOrValue<BigNumberish>,
      expirationTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    protocolFeeRecipient(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Allows the current owner to relinquish control of the contract.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    ordersCanMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    approveOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      orderbookInclusionDesired: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumMakerProtocolFee(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Call hashToSign - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    hashToSign_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelledOrFinalized(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exchangeToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    cancelOrder_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    atomicMatch_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      vs: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      rssMetadata: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
      ],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call validateOrderParameters - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    validateOrderParameters_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    INVERSE_BASIS_POINT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.
     */
    calculateMatchPrice_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethodsSidesKindsHowToCalls: PromiseOrValue<BigNumberish>[],
      calldataBuy: PromiseOrValue<BytesLike>,
      calldataSell: PromiseOrValue<BytesLike>,
      replacementPatternBuy: PromiseOrValue<BytesLike>,
      replacementPatternSell: PromiseOrValue<BytesLike>,
      staticExtradataBuy: PromiseOrValue<BytesLike>,
      staticExtradataSell: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Determine if an order has been approved. Note that the order may not still be valid in cases where the maker's nonce has been incremented.
     * @param hash Hash of the order
     * @returns whether or not the order was approved.
     */
    approvedOrders(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call cancelOrder, supplying a specific nonce — enables cancelling orders that were signed with nonces greater than the current nonce.
     */
    cancelOrderWithNonce_(
      addrs: PromiseOrValue<string>[],
      uints: PromiseOrValue<BigNumberish>[],
      feeMethod: PromiseOrValue<BigNumberish>,
      side: PromiseOrValue<BigNumberish>,
      saleKind: PromiseOrValue<BigNumberish>,
      howToCall: PromiseOrValue<BigNumberish>,
      calldata: PromiseOrValue<BytesLike>,
      replacementPattern: PromiseOrValue<BytesLike>,
      staticExtradata: PromiseOrValue<BytesLike>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
